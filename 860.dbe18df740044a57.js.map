{"version":3,"file":"860.dbe18df740044a57.js","mappings":"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","names":["Observable","constructor","subscribe","this","_subscribe","lift","operator","observable","source","observerOrNext","error","complete","subscriber","isSubscriber","value","Subscriber","isObserver","isFunction","next","isSubscription","SafeSubscriber","errorContext","add","call","_trySubscribe","sink","err","forEach","promiseCtor","getPromiseCtor","resolve","reject","unsubscribe","_a","Symbol_observable","pipe","operations","pipeFromArray","toPromise","x","create","config","Promise","COMPLETE_NOTIFICATION","createNotification","undefined","kind","Subscription","destination","super","isStopped","EMPTY_OBSERVER","handleStoppedNotification","nextNotification","_next","errorNotification","_error","_complete","closed","_bind","Function","prototype","bind","fn","thisArg","ConsumerObserver","partialObserver","handleUnhandledError","context","useDeprecatedNextContext","Object","useDeprecatedSynchronousErrorHandling","captureError","reportUnhandledError","notification","onStoppedNotification","timeoutProvider","setTimeout","noop","defaultErrorHandler","UnsubscriptionError","createErrorClass","_super","errors","message","length","map","i","toString","join","name","initialTeardown","_parentage","_finalizers","Array","isArray","parent","remove","initialFinalizer","e","finalizer","execFinalizer","push","teardown","_hasParent","_addParent","includes","_removeParent","arrRemove","EMPTY","empty","EMPTY_SUBSCRIPTION","onUnhandledError","subscribeOn","scheduler","delay","operate","schedule","scheduleAsyncIterable","input","Error","executeSchedule","iterator","Symbol","asyncIterator","then","result","done","from","scheduled","isInteropObservable","scheduleObservable","innerFrom","observeOn","isArrayLike","scheduleArray","isPromise","schedulePromise","isAsyncIterable","isIterable","scheduleIterable","Symbol_iterator","return","isReadableStreamLike","scheduleReadableStreamLike","readableStreamLikeToAsyncGenerator","createInvalidObservableTypeError","fromInteropObservable","obj","obs","TypeError","fromArrayLike","array","fromPromise","promise","fromAsyncIterable","fromIterable","iterable","fromReadableStreamLike","readableStream","asyncIterable","process","asyncIterable_1","asyncIterable_1_1","e_1","__awaiter","__asyncValues","e_1_1","catch","of","args","popScheduler","createOperatorSubscriber","onNext","onComplete","onError","onFinalize","OperatorSubscriber","shouldUnsubscribe","concatMap","project","resultSelector","mergeMap","filter","predicate","index","finalize","callback","concurrent","Infinity","a","b","ii","mergeInternals","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","buffer","active","isComplete","checkComplete","outerNext","doInnerSub","innerComplete","innerValue","bufferedValue","shift","switchMap","innerSubscriber","innerIndex","outerIndex","tap","tapObserver","isUnsub","_b","identity","handler","timeout","delegate","clearTimeout","handle","getSymbolIterator","last","arr","popResultSelector","pop","isScheduler","popNumber","defaultValue","item","indexOf","splice","createImpl","ctorFunc","instance","stack","cb","isRoot","errorThrown","parentSubscription","work","repeat","scheduleSubscription","__asyncGenerator","arguments","reader","getReader","__await","read","releaseLock","hasLift","init","liftedSource","fns","reduce","prev","HttpHandler","HttpBackend","HttpHeaders","headers","normalizedNames","Map","lazyUpdate","lazyInit","split","line","slice","key","toLowerCase","trim","maybeSetNormalizedName","has","get","set","Headers","values","setHeaderEntries","entries","keys","getAll","append","clone","op","delete","lcName","copyFrom","update","applyUpdate","other","concat","base","toDelete","existing","headerValues","HttpUrlEncodingCodec","encodeKey","standardEncoding","encodeValue","decodeKey","decodeURIComponent","decodeValue","STANDARD_ENCODING_REGEX","STANDARD_ENCODING_REPLACEMENTS","v","encodeURIComponent","replace","s","t","valueToString","HttpParams","options","updates","cloneFrom","encoder","fromString","fromObject","paramParser","rawParams","codec","param","eqIdx","val","list","res","appendAll","params","_value","eKey","idx","HttpContextToken","HttpContext","token","isArrayBuffer","ArrayBuffer","isBlob","Blob","isFormData","FormData","HttpRequest","method","url","third","fourth","body","reportProgress","withCredentials","responseType","toUpperCase","mightHaveBody","transferCache","urlWithParams","qIdx","serializeBody","isUrlSearchParams","URLSearchParams","JSON","stringify","detectContentTypeHeader","type","setHeaders","setParams","HttpEventType","Sent","UploadProgress","ResponseHeader","DownloadProgress","Response","User","HttpResponseBase","defaultStatus","defaultStatusText","status","statusText","ok","HttpHeaderResponse","HttpResponse","HttpErrorResponse","addBody","observe","HttpClient","request","first","req","events$","res$","event","head","jsonp","callbackParam","patch","post","put","static","fac","i0","prov","factory","XSSI_PREFIX$1","getResponseUrl$1","response","xRequestUrl","toLocaleLowerCase","FetchBackend","fetchImpl","inject","FetchFactory","optional","fetch","globalThis","ngZone","NgZone","observer","aborter","AbortController","doRequest","signal","abort","_this","_asyncToGenerator","createRequestInit","fetchPromise","silenceSuperfluousUnhandledPromiseRejection","contentLength","chunks","decoder","partialText","receivedLength","reqZone","Zone","current","runOutsideAngular","TextDecoder","decode","stream","total","loaded","run","chunksAll","concatChunks","contentType","parseBody","binContent","text","parse","credentials","Accept","detectedType","totalLength","Uint8Array","position","chunk","interceptorChainEndFn","finalHandlerFn","adaptLegacyInterceptorToChain","chainTailFn","interceptor","initialRequest","intercept","downstreamRequest","HTTP_INTERCEPTORS","InjectionToken","HTTP_INTERCEPTOR_FNS","HTTP_ROOT_INTERCEPTOR_FNS","PRIMARY_HTTP_BACKEND","legacyInterceptorFnFactory","chain","reduceRight","pendingTasks","InitialRenderPendingTasks","taskId","foreignDocument","HttpInterceptorHandler","backend","injector","primaryHttpBackend","dedupedInterceptorFns","Set","nextSequencedFn","interceptorFn","chainedInterceptorFn","runInInjectionContext","nextRequestId","JsonpCallbackContext","jsonpCallbackContext","window","JsonpClientBackend","callbackMap","document","resolvedPromise","nextCallback","node","createElement","src","finished","data","cleanup","parentNode","removeChild","addEventListener","appendChild","removeListeners","script","implementation","createHTMLDocument","adoptNode","DOCUMENT","jsonpInterceptorFn","JsonpInterceptor","XSSI_PREFIX","HttpXhrBackend","xhrFactory","RuntimeError","ngDevMode","loadImpl","xhr","build","open","setRequestHeader","reqBody","headerResponse","partialFromXhr","getAllResponseHeaders","getResponseUrl","responseURL","test","getResponseHeader","onLoad","responseText","originalBody","sentHeaders","onDownProgress","progressEvent","lengthComputable","onUpProgress","progress","upload","send","removeEventListener","readyState","DONE","i1","XSRF_ENABLED","XSRF_DEFAULT_COOKIE_NAME","XSRF_COOKIE_NAME","providedIn","XSRF_DEFAULT_HEADER_NAME","XSRF_HEADER_NAME","HttpXsrfTokenExtractor","HttpXsrfCookieExtractor","doc","platform","cookieName","lastCookieString","lastToken","parseCount","getToken","cookieString","cookie","parseCookieValue","PLATFORM_ID","xsrfInterceptorFn","lcUrl","startsWith","headerName","HttpXsrfInterceptor","HttpFeatureKind","Interceptors","LegacyInterceptors","CustomXsrfConfiguration","NoXsrfProtection","JsonpSupport","RequestsMadeViaParent","Fetch","makeHttpFeature","providers","kind","providers","provideHttpClient","features","provide","useExisting","useValue","multi","useClass","feature","makeEnvironmentProviders","withInterceptors","interceptorFns","LEGACY_INTERCEPTOR_FN","withInterceptorsFromDi","useFactory","withXsrfConfiguration","withNoXsrfProtection","withJsonpSupport","withRequestsMadeViaParent","skipSelf","withFetch","HttpClientXsrfModule","disable","ngModule","withOptions","mod","inj","HttpClientModule","HttpClientJsonpModule","BODY","HEADERS","STATUS","STATUS_TEXT","URL","RESPONSE_TYPE","CACHE_OPTIONS","ALLOWED_METHODS","transferCacheInterceptorFn","isCacheActive","globalOptions","requestOptions","requestMethod","includePostRequests","transferState","TransferState","storeKey","makeCacheKey","encodedParams","sort","k","hash","generateHash","char","Math","imul","charCodeAt","makeStateKey","headersToInclude","includeHeaders","Ye","undecodedBody","tt","Ze","httpHeaders","Qe","qe","et","TextEncoder","encode","getFilteredHeaders","headersMap","withHttpTransferCache","cacheOptions","performanceMarkFeature","deps","APP_BOOTSTRAP_LISTENER","appRef","ApplicationRef","cacheState","whenStable","asyncGeneratorStep","gen","_throw","arg","info","self","apply","extendStatics","d","setPrototypeOf","__proto__","p","hasOwnProperty","__extends","String","__","__assign","assign","n","__rest","getOwnPropertySymbols","propertyIsEnumerable","_arguments","P","generator","fulfilled","step","rejected","throw","adopt","__generator","f","y","g","_","label","sent","trys","ops","verb","__spreadArray","to","pack","ar","l","q","resume","r","fulfill","settle","o","m","__values","SuppressedError"],"sourceRoot":"webpack:///","sources":["./node_modules/rxjs/dist/esm/internal/Observable.js","./node_modules/rxjs/dist/esm/internal/NotificationFactories.js","./node_modules/rxjs/dist/esm/internal/Subscriber.js","./node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js","./node_modules/rxjs/dist/esm/internal/Subscription.js","./node_modules/rxjs/dist/esm/internal/config.js","./node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js","./node_modules/rxjs/dist/esm/internal/observable/from.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js","./node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js","./node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js","./node_modules/rxjs/dist/esm/internal/observable/innerFrom.js","./node_modules/rxjs/dist/esm/internal/observable/of.js","./node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js","./node_modules/rxjs/dist/esm/internal/operators/concatMap.js","./node_modules/rxjs/dist/esm/internal/operators/filter.js","./node_modules/rxjs/dist/esm/internal/operators/finalize.js","./node_modules/rxjs/dist/esm/internal/operators/map.js","./node_modules/rxjs/dist/esm/internal/operators/mergeMap.js","./node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js","./node_modules/rxjs/dist/esm/internal/operators/observeOn.js","./node_modules/rxjs/dist/esm/internal/operators/switchMap.js","./node_modules/rxjs/dist/esm/internal/operators/tap.js","./node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js","./node_modules/rxjs/dist/esm/internal/symbol/iterator.js","./node_modules/rxjs/dist/esm/internal/symbol/observable.js","./node_modules/rxjs/dist/esm/internal/util/args.js","./node_modules/rxjs/dist/esm/internal/util/arrRemove.js","./node_modules/rxjs/dist/esm/internal/util/createErrorClass.js","./node_modules/rxjs/dist/esm/internal/util/errorContext.js","./node_modules/rxjs/dist/esm/internal/util/executeSchedule.js","./node_modules/rxjs/dist/esm/internal/util/identity.js","./node_modules/rxjs/dist/esm/internal/util/isArrayLike.js","./node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js","./node_modules/rxjs/dist/esm/internal/util/isFunction.js","./node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js","./node_modules/rxjs/dist/esm/internal/util/isIterable.js","./node_modules/rxjs/dist/esm/internal/util/isPromise.js","./node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js","./node_modules/rxjs/dist/esm/internal/util/isScheduler.js","./node_modules/rxjs/dist/esm/internal/util/lift.js","./node_modules/rxjs/dist/esm/internal/util/noop.js","./node_modules/rxjs/dist/esm/internal/util/pipe.js","./node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js","./node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js","./node_modules/@angular/common/fesm2022/http.mjs","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","./node_modules/tslib/tslib.es6.mjs"],"sourcesContent":["import { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription } from './Subscription';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\nexport class Observable {\n    constructor(subscribe) {\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    lift(operator) {\n        const observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n    subscribe(observerOrNext, error, complete) {\n        const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n        errorContext(() => {\n            const { operator, source } = this;\n            subscriber.add(operator\n                ?\n                    operator.call(subscriber, source)\n                : source\n                    ?\n                        this._subscribe(subscriber)\n                    :\n                        this._trySubscribe(subscriber));\n        });\n        return subscriber;\n    }\n    _trySubscribe(sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.error(err);\n        }\n    }\n    forEach(next, promiseCtor) {\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor((resolve, reject) => {\n            const subscriber = new SafeSubscriber({\n                next: (value) => {\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscriber.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve,\n            });\n            this.subscribe(subscriber);\n        });\n    }\n    _subscribe(subscriber) {\n        var _a;\n        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\n    }\n    [Symbol_observable]() {\n        return this;\n    }\n    pipe(...operations) {\n        return pipeFromArray(operations)(this);\n    }\n    toPromise(promiseCtor) {\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor((resolve, reject) => {\n            let value;\n            this.subscribe((x) => (value = x), (err) => reject(err), () => resolve(value));\n        });\n    }\n}\nObservable.create = (subscribe) => {\n    return new Observable(subscribe);\n};\nfunction getPromiseCtor(promiseCtor) {\n    var _a;\n    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;\n}\nfunction isObserver(value) {\n    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\nfunction isSubscriber(value) {\n    return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n","export const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined))();\nexport function errorNotification(error) {\n    return createNotification('E', undefined, error);\n}\nexport function nextNotification(value) {\n    return createNotification('N', value, undefined);\n}\nexport function createNotification(kind, value, error) {\n    return {\n        kind,\n        value,\n        error,\n    };\n}\n","import { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nexport class Subscriber extends Subscription {\n    constructor(destination) {\n        super();\n        this.isStopped = false;\n        if (destination) {\n            this.destination = destination;\n            if (isSubscription(destination)) {\n                destination.add(this);\n            }\n        }\n        else {\n            this.destination = EMPTY_OBSERVER;\n        }\n    }\n    static create(next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    }\n    next(value) {\n        if (this.isStopped) {\n            handleStoppedNotification(nextNotification(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    }\n    error(err) {\n        if (this.isStopped) {\n            handleStoppedNotification(errorNotification(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    }\n    complete() {\n        if (this.isStopped) {\n            handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    }\n    unsubscribe() {\n        if (!this.closed) {\n            this.isStopped = true;\n            super.unsubscribe();\n            this.destination = null;\n        }\n    }\n    _next(value) {\n        this.destination.next(value);\n    }\n    _error(err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n    _complete() {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n}\nconst _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n    return _bind.call(fn, thisArg);\n}\nclass ConsumerObserver {\n    constructor(partialObserver) {\n        this.partialObserver = partialObserver;\n    }\n    next(value) {\n        const { partialObserver } = this;\n        if (partialObserver.next) {\n            try {\n                partialObserver.next(value);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    }\n    error(err) {\n        const { partialObserver } = this;\n        if (partialObserver.error) {\n            try {\n                partialObserver.error(err);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n        else {\n            handleUnhandledError(err);\n        }\n    }\n    complete() {\n        const { partialObserver } = this;\n        if (partialObserver.complete) {\n            try {\n                partialObserver.complete();\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    }\n}\nexport class SafeSubscriber extends Subscriber {\n    constructor(observerOrNext, error, complete) {\n        super();\n        let partialObserver;\n        if (isFunction(observerOrNext) || !observerOrNext) {\n            partialObserver = {\n                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),\n                error: error !== null && error !== void 0 ? error : undefined,\n                complete: complete !== null && complete !== void 0 ? complete : undefined,\n            };\n        }\n        else {\n            let context;\n            if (this && config.useDeprecatedNextContext) {\n                context = Object.create(observerOrNext);\n                context.unsubscribe = () => this.unsubscribe();\n                partialObserver = {\n                    next: observerOrNext.next && bind(observerOrNext.next, context),\n                    error: observerOrNext.error && bind(observerOrNext.error, context),\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n                };\n            }\n            else {\n                partialObserver = observerOrNext;\n            }\n        }\n        this.destination = new ConsumerObserver(partialObserver);\n    }\n}\nfunction handleUnhandledError(error) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        captureError(error);\n    }\n    else {\n        reportUnhandledError(error);\n    }\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    const { onStoppedNotification } = config;\n    onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\nexport const EMPTY_OBSERVER = {\n    closed: true,\n    next: noop,\n    error: defaultErrorHandler,\n    complete: noop,\n};\n","import { createErrorClass } from './createErrorClass';\nexport const UnsubscriptionError = createErrorClass((_super) => function UnsubscriptionErrorImpl(errors) {\n    _super(this);\n    this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n    this.name = 'UnsubscriptionError';\n    this.errors = errors;\n});\n","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { arrRemove } from './util/arrRemove';\nexport class Subscription {\n    constructor(initialTeardown) {\n        this.initialTeardown = initialTeardown;\n        this.closed = false;\n        this._parentage = null;\n        this._finalizers = null;\n    }\n    unsubscribe() {\n        let errors;\n        if (!this.closed) {\n            this.closed = true;\n            const { _parentage } = this;\n            if (_parentage) {\n                this._parentage = null;\n                if (Array.isArray(_parentage)) {\n                    for (const parent of _parentage) {\n                        parent.remove(this);\n                    }\n                }\n                else {\n                    _parentage.remove(this);\n                }\n            }\n            const { initialTeardown: initialFinalizer } = this;\n            if (isFunction(initialFinalizer)) {\n                try {\n                    initialFinalizer();\n                }\n                catch (e) {\n                    errors = e instanceof UnsubscriptionError ? e.errors : [e];\n                }\n            }\n            const { _finalizers } = this;\n            if (_finalizers) {\n                this._finalizers = null;\n                for (const finalizer of _finalizers) {\n                    try {\n                        execFinalizer(finalizer);\n                    }\n                    catch (err) {\n                        errors = errors !== null && errors !== void 0 ? errors : [];\n                        if (err instanceof UnsubscriptionError) {\n                            errors = [...errors, ...err.errors];\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n            if (errors) {\n                throw new UnsubscriptionError(errors);\n            }\n        }\n    }\n    add(teardown) {\n        var _a;\n        if (teardown && teardown !== this) {\n            if (this.closed) {\n                execFinalizer(teardown);\n            }\n            else {\n                if (teardown instanceof Subscription) {\n                    if (teardown.closed || teardown._hasParent(this)) {\n                        return;\n                    }\n                    teardown._addParent(this);\n                }\n                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);\n            }\n        }\n    }\n    _hasParent(parent) {\n        const { _parentage } = this;\n        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n    }\n    _addParent(parent) {\n        const { _parentage } = this;\n        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n    }\n    _removeParent(parent) {\n        const { _parentage } = this;\n        if (_parentage === parent) {\n            this._parentage = null;\n        }\n        else if (Array.isArray(_parentage)) {\n            arrRemove(_parentage, parent);\n        }\n    }\n    remove(teardown) {\n        const { _finalizers } = this;\n        _finalizers && arrRemove(_finalizers, teardown);\n        if (teardown instanceof Subscription) {\n            teardown._removeParent(this);\n        }\n    }\n}\nSubscription.EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n})();\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\nexport function isSubscription(value) {\n    return (value instanceof Subscription ||\n        (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));\n}\nfunction execFinalizer(finalizer) {\n    if (isFunction(finalizer)) {\n        finalizer();\n    }\n    else {\n        finalizer.unsubscribe();\n    }\n}\n","export const config = {\n    onUnhandledError: null,\n    onStoppedNotification: null,\n    Promise: undefined,\n    useDeprecatedSynchronousErrorHandling: false,\n    useDeprecatedNextContext: false,\n};\n","import { operate } from '../util/lift';\nexport function subscribeOn(scheduler, delay = 0) {\n    return operate((source, subscriber) => {\n        subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n    });\n}\n","import { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function scheduleAsyncIterable(input, scheduler) {\n    if (!input) {\n        throw new Error('Iterable cannot be null');\n    }\n    return new Observable((subscriber) => {\n        executeSchedule(subscriber, scheduler, () => {\n            const iterator = input[Symbol.asyncIterator]();\n            executeSchedule(subscriber, scheduler, () => {\n                iterator.next().then((result) => {\n                    if (result.done) {\n                        subscriber.complete();\n                    }\n                    else {\n                        subscriber.next(result.value);\n                    }\n                });\n            }, 0, true);\n        });\n    });\n}\n","import { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\nexport function from(input, scheduler) {\n    return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n","import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\nexport function scheduled(input, scheduler) {\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return scheduleObservable(input, scheduler);\n        }\n        if (isArrayLike(input)) {\n            return scheduleArray(input, scheduler);\n        }\n        if (isPromise(input)) {\n            return schedulePromise(input, scheduler);\n        }\n        if (isAsyncIterable(input)) {\n            return scheduleAsyncIterable(input, scheduler);\n        }\n        if (isIterable(input)) {\n            return scheduleIterable(input, scheduler);\n        }\n        if (isReadableStreamLike(input)) {\n            return scheduleReadableStreamLike(input, scheduler);\n        }\n    }\n    throw createInvalidObservableTypeError(input);\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nexport function scheduleObservable(input, scheduler) {\n    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { Observable } from '../Observable';\nexport function scheduleArray(input, scheduler) {\n    return new Observable((subscriber) => {\n        let i = 0;\n        return scheduler.schedule(function () {\n            if (i === input.length) {\n                subscriber.complete();\n            }\n            else {\n                subscriber.next(input[i++]);\n                if (!subscriber.closed) {\n                    this.schedule();\n                }\n            }\n        });\n    });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nexport function schedulePromise(input, scheduler) {\n    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { Observable } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function scheduleIterable(input, scheduler) {\n    return new Observable((subscriber) => {\n        let iterator;\n        executeSchedule(subscriber, scheduler, () => {\n            iterator = input[Symbol_iterator]();\n            executeSchedule(subscriber, scheduler, () => {\n                let value;\n                let done;\n                try {\n                    ({ value, done } = iterator.next());\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (done) {\n                    subscriber.complete();\n                }\n                else {\n                    subscriber.next(value);\n                }\n            }, 0, true);\n        });\n        return () => isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();\n    });\n}\n","import { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nexport function scheduleReadableStreamLike(input, scheduler) {\n    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n","import { __asyncValues, __awaiter } from \"tslib\";\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\nexport function innerFrom(input) {\n    if (input instanceof Observable) {\n        return input;\n    }\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return fromInteropObservable(input);\n        }\n        if (isArrayLike(input)) {\n            return fromArrayLike(input);\n        }\n        if (isPromise(input)) {\n            return fromPromise(input);\n        }\n        if (isAsyncIterable(input)) {\n            return fromAsyncIterable(input);\n        }\n        if (isIterable(input)) {\n            return fromIterable(input);\n        }\n        if (isReadableStreamLike(input)) {\n            return fromReadableStreamLike(input);\n        }\n    }\n    throw createInvalidObservableTypeError(input);\n}\nexport function fromInteropObservable(obj) {\n    return new Observable((subscriber) => {\n        const obs = obj[Symbol_observable]();\n        if (isFunction(obs.subscribe)) {\n            return obs.subscribe(subscriber);\n        }\n        throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    });\n}\nexport function fromArrayLike(array) {\n    return new Observable((subscriber) => {\n        for (let i = 0; i < array.length && !subscriber.closed; i++) {\n            subscriber.next(array[i]);\n        }\n        subscriber.complete();\n    });\n}\nexport function fromPromise(promise) {\n    return new Observable((subscriber) => {\n        promise\n            .then((value) => {\n            if (!subscriber.closed) {\n                subscriber.next(value);\n                subscriber.complete();\n            }\n        }, (err) => subscriber.error(err))\n            .then(null, reportUnhandledError);\n    });\n}\nexport function fromIterable(iterable) {\n    return new Observable((subscriber) => {\n        for (const value of iterable) {\n            subscriber.next(value);\n            if (subscriber.closed) {\n                return;\n            }\n        }\n        subscriber.complete();\n    });\n}\nexport function fromAsyncIterable(asyncIterable) {\n    return new Observable((subscriber) => {\n        process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n    });\n}\nexport function fromReadableStreamLike(readableStream) {\n    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\nfunction process(asyncIterable, subscriber) {\n    var asyncIterable_1, asyncIterable_1_1;\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            for (asyncIterable_1 = __asyncValues(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), !asyncIterable_1_1.done;) {\n                const value = asyncIterable_1_1.value;\n                subscriber.next(value);\n                if (subscriber.closed) {\n                    return;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)) yield _a.call(asyncIterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        subscriber.complete();\n    });\n}\n","import { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function of(...args) {\n    const scheduler = popScheduler(args);\n    return from(args, scheduler);\n}\n","import { Subscriber } from '../Subscriber';\nexport function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nexport class OperatorSubscriber extends Subscriber {\n    constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n        super(destination);\n        this.onFinalize = onFinalize;\n        this.shouldUnsubscribe = shouldUnsubscribe;\n        this._next = onNext\n            ? function (value) {\n                try {\n                    onNext(value);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n            }\n            : super._next;\n        this._error = onError\n            ? function (err) {\n                try {\n                    onError(err);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : super._error;\n        this._complete = onComplete\n            ? function () {\n                try {\n                    onComplete();\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : super._complete;\n    }\n    unsubscribe() {\n        var _a;\n        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n            const { closed } = this;\n            super.unsubscribe();\n            !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n        }\n    }\n}\n","import { mergeMap } from './mergeMap';\nimport { isFunction } from '../util/isFunction';\nexport function concatMap(project, resultSelector) {\n    return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function filter(predicate, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value)));\n    });\n}\n","import { operate } from '../util/lift';\nexport function finalize(callback) {\n    return operate((source, subscriber) => {\n        try {\n            source.subscribe(subscriber);\n        }\n        finally {\n            subscriber.add(callback);\n        }\n    });\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function map(project, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            subscriber.next(project.call(thisArg, value, index++));\n        }));\n    });\n}\n","import { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\nexport function mergeMap(project, resultSelector, concurrent = Infinity) {\n    if (isFunction(resultSelector)) {\n        return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    const buffer = [];\n    let active = 0;\n    let index = 0;\n    let isComplete = false;\n    const checkComplete = () => {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    const outerNext = (value) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n    const doInnerSub = (value) => {\n        expand && subscriber.next(value);\n        active++;\n        let innerComplete = false;\n        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            }\n            else {\n                subscriber.next(innerValue);\n            }\n        }, () => {\n            innerComplete = true;\n        }, undefined, () => {\n            if (innerComplete) {\n                try {\n                    active--;\n                    while (buffer.length && active < concurrent) {\n                        const bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                        }\n                        else {\n                            doInnerSub(bufferedValue);\n                        }\n                    }\n                    checkComplete();\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {\n        isComplete = true;\n        checkComplete();\n    }));\n    return () => {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n}\n","import { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function observeOn(scheduler, delay = 0) {\n    return operate((source, subscriber) => {\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay), () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay), (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)));\n    });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function switchMap(project, resultSelector) {\n    return operate((source, subscriber) => {\n        let innerSubscriber = null;\n        let index = 0;\n        let isComplete = false;\n        const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();\n            let innerIndex = 0;\n            const outerIndex = index++;\n            innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {\n                innerSubscriber = null;\n                checkComplete();\n            })));\n        }, () => {\n            isComplete = true;\n            checkComplete();\n        }));\n    });\n}\n","import { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nexport function tap(observerOrNext, error, complete) {\n    const tapObserver = isFunction(observerOrNext) || error || complete\n        ?\n            { next: observerOrNext, error, complete }\n        : observerOrNext;\n    return tapObserver\n        ? operate((source, subscriber) => {\n            var _a;\n            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n            let isUnsub = true;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                var _a;\n                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);\n                subscriber.next(value);\n            }, () => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                subscriber.complete();\n            }, (err) => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);\n                subscriber.error(err);\n            }, () => {\n                var _a, _b;\n                if (isUnsub) {\n                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                }\n                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);\n            }));\n        })\n        :\n            identity;\n}\n","export const timeoutProvider = {\n    setTimeout(handler, timeout, ...args) {\n        const { delegate } = timeoutProvider;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {\n            return delegate.setTimeout(handler, timeout, ...args);\n        }\n        return setTimeout(handler, timeout, ...args);\n    },\n    clearTimeout(handle) {\n        const { delegate } = timeoutProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\n    },\n    delegate: undefined,\n};\n","export function getSymbolIterator() {\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\n        return '@@iterator';\n    }\n    return Symbol.iterator;\n}\nexport const iterator = getSymbolIterator();\n","export const observable = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n","import { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nexport function popResultSelector(args) {\n    return isFunction(last(args)) ? args.pop() : undefined;\n}\nexport function popScheduler(args) {\n    return isScheduler(last(args)) ? args.pop() : undefined;\n}\nexport function popNumber(args, defaultValue) {\n    return typeof last(args) === 'number' ? args.pop() : defaultValue;\n}\n","export function arrRemove(arr, item) {\n    if (arr) {\n        const index = arr.indexOf(item);\n        0 <= index && arr.splice(index, 1);\n    }\n}\n","export function createErrorClass(createImpl) {\n    const _super = (instance) => {\n        Error.call(instance);\n        instance.stack = new Error().stack;\n    };\n    const ctorFunc = createImpl(_super);\n    ctorFunc.prototype = Object.create(Error.prototype);\n    ctorFunc.prototype.constructor = ctorFunc;\n    return ctorFunc;\n}\n","import { config } from '../config';\nlet context = null;\nexport function errorContext(cb) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        const isRoot = !context;\n        if (isRoot) {\n            context = { errorThrown: false, error: null };\n        }\n        cb();\n        if (isRoot) {\n            const { errorThrown, error } = context;\n            context = null;\n            if (errorThrown) {\n                throw error;\n            }\n        }\n    }\n    else {\n        cb();\n    }\n}\nexport function captureError(err) {\n    if (config.useDeprecatedSynchronousErrorHandling && context) {\n        context.errorThrown = true;\n        context.error = err;\n    }\n}\n","export function executeSchedule(parentSubscription, scheduler, work, delay = 0, repeat = false) {\n    const scheduleSubscription = scheduler.schedule(function () {\n        work();\n        if (repeat) {\n            parentSubscription.add(this.schedule(null, delay));\n        }\n        else {\n            this.unsubscribe();\n        }\n    }, delay);\n    parentSubscription.add(scheduleSubscription);\n    if (!repeat) {\n        return scheduleSubscription;\n    }\n}\n","export function identity(x) {\n    return x;\n}\n","export const isArrayLike = ((x) => x && typeof x.length === 'number' && typeof x !== 'function');\n","import { isFunction } from './isFunction';\nexport function isAsyncIterable(obj) {\n    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);\n}\n","export function isFunction(value) {\n    return typeof value === 'function';\n}\n","import { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\nexport function isInteropObservable(input) {\n    return isFunction(input[Symbol_observable]);\n}\n","import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\nexport function isIterable(input) {\n    return isFunction(input === null || input === void 0 ? void 0 : input[Symbol_iterator]);\n}\n","import { isFunction } from \"./isFunction\";\nexport function isPromise(value) {\n    return isFunction(value === null || value === void 0 ? void 0 : value.then);\n}\n","import { __asyncGenerator, __await } from \"tslib\";\nimport { isFunction } from './isFunction';\nexport function readableStreamLikeToAsyncGenerator(readableStream) {\n    return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {\n        const reader = readableStream.getReader();\n        try {\n            while (true) {\n                const { value, done } = yield __await(reader.read());\n                if (done) {\n                    return yield __await(void 0);\n                }\n                yield yield __await(value);\n            }\n        }\n        finally {\n            reader.releaseLock();\n        }\n    });\n}\nexport function isReadableStreamLike(obj) {\n    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);\n}\n","import { isFunction } from './isFunction';\nexport function isScheduler(value) {\n    return value && isFunction(value.schedule);\n}\n","import { isFunction } from './isFunction';\nexport function hasLift(source) {\n    return isFunction(source === null || source === void 0 ? void 0 : source.lift);\n}\nexport function operate(init) {\n    return (source) => {\n        if (hasLift(source)) {\n            return source.lift(function (liftedSource) {\n                try {\n                    return init(liftedSource, this);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            });\n        }\n        throw new TypeError('Unable to lift unknown Observable type');\n    };\n}\n","export function noop() { }\n","import { identity } from './identity';\nexport function pipe(...fns) {\n    return pipeFromArray(fns);\n}\nexport function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce((prev, fn) => fn(prev), input);\n    };\n}\n","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\nexport function reportUnhandledError(err) {\n    timeoutProvider.setTimeout(() => {\n        const { onUnhandledError } = config;\n        if (onUnhandledError) {\n            onUnhandledError(err);\n        }\n        else {\n            throw err;\n        }\n    });\n}\n","export function createInvalidObservableTypeError(input) {\n    return new TypeError(`You provided ${input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);\n}\n","/**\n * @license Angular v17.0.6\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { Injectable, inject, NgZone, runInInjectionContext, InjectionToken, InitialRenderPendingTasks, PLATFORM_ID, Console, formatRuntimeError, Inject, RuntimeError, makeEnvironmentProviders, NgModule, TransferState, makeStateKey, performanceMarkFeature, APP_BOOTSTRAP_LISTENER, ApplicationRef, whenStable, truncateMiddle } from '@angular/core';\nimport { of, Observable, from } from 'rxjs';\nimport { concatMap, filter, map, finalize, switchMap, tap } from 'rxjs/operators';\nimport * as i1 from '@angular/common';\nimport { isPlatformServer, DOCUMENT, parseCookieValue } from '@angular/common';\n\n/**\n * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a\n * `HttpResponse`.\n *\n * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the\n * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the\n * `HttpBackend`.\n *\n * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.\n *\n * @publicApi\n */\nclass HttpHandler {\n}\n/**\n * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.\n *\n * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.\n *\n * When injected, `HttpBackend` dispatches requests directly to the backend, without going\n * through the interceptor chain.\n *\n * @publicApi\n */\nclass HttpBackend {\n}\n\n/**\n * Represents the header configuration options for an HTTP request.\n * Instances are immutable. Modifying methods return a cloned\n * instance with the change. The original object is never changed.\n *\n * @publicApi\n */\nclass HttpHeaders {\n    /**  Constructs a new HTTP header object with the given values.*/\n    constructor(headers) {\n        /**\n         * Internal map of lowercased header names to the normalized\n         * form of the name (the form seen first).\n         */\n        this.normalizedNames = new Map();\n        /**\n         * Queued updates to be materialized the next initialization.\n         */\n        this.lazyUpdate = null;\n        if (!headers) {\n            this.headers = new Map();\n        }\n        else if (typeof headers === 'string') {\n            this.lazyInit = () => {\n                this.headers = new Map();\n                headers.split('\\n').forEach(line => {\n                    const index = line.indexOf(':');\n                    if (index > 0) {\n                        const name = line.slice(0, index);\n                        const key = name.toLowerCase();\n                        const value = line.slice(index + 1).trim();\n                        this.maybeSetNormalizedName(name, key);\n                        if (this.headers.has(key)) {\n                            this.headers.get(key).push(value);\n                        }\n                        else {\n                            this.headers.set(key, [value]);\n                        }\n                    }\n                });\n            };\n        }\n        else if (typeof Headers !== 'undefined' && headers instanceof Headers) {\n            this.headers = new Map();\n            headers.forEach((values, name) => {\n                this.setHeaderEntries(name, values);\n            });\n        }\n        else {\n            this.lazyInit = () => {\n                if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                    assertValidHeaders(headers);\n                }\n                this.headers = new Map();\n                Object.entries(headers).forEach(([name, values]) => {\n                    this.setHeaderEntries(name, values);\n                });\n            };\n        }\n    }\n    /**\n     * Checks for existence of a given header.\n     *\n     * @param name The header name to check for existence.\n     *\n     * @returns True if the header exists, false otherwise.\n     */\n    has(name) {\n        this.init();\n        return this.headers.has(name.toLowerCase());\n    }\n    /**\n     * Retrieves the first value of a given header.\n     *\n     * @param name The header name.\n     *\n     * @returns The value string if the header exists, null otherwise\n     */\n    get(name) {\n        this.init();\n        const values = this.headers.get(name.toLowerCase());\n        return values && values.length > 0 ? values[0] : null;\n    }\n    /**\n     * Retrieves the names of the headers.\n     *\n     * @returns A list of header names.\n     */\n    keys() {\n        this.init();\n        return Array.from(this.normalizedNames.values());\n    }\n    /**\n     * Retrieves a list of values for a given header.\n     *\n     * @param name The header name from which to retrieve values.\n     *\n     * @returns A string of values if the header exists, null otherwise.\n     */\n    getAll(name) {\n        this.init();\n        return this.headers.get(name.toLowerCase()) || null;\n    }\n    /**\n     * Appends a new value to the existing set of values for a header\n     * and returns them in a clone of the original instance.\n     *\n     * @param name The header name for which to append the values.\n     * @param value The value to append.\n     *\n     * @returns A clone of the HTTP headers object with the value appended to the given header.\n     */\n    append(name, value) {\n        return this.clone({ name, value, op: 'a' });\n    }\n    /**\n     * Sets or modifies a value for a given header in a clone of the original instance.\n     * If the header already exists, its value is replaced with the given value\n     * in the returned object.\n     *\n     * @param name The header name.\n     * @param value The value or values to set or override for the given header.\n     *\n     * @returns A clone of the HTTP headers object with the newly set header value.\n     */\n    set(name, value) {\n        return this.clone({ name, value, op: 's' });\n    }\n    /**\n     * Deletes values for a given header in a clone of the original instance.\n     *\n     * @param name The header name.\n     * @param value The value or values to delete for the given header.\n     *\n     * @returns A clone of the HTTP headers object with the given value deleted.\n     */\n    delete(name, value) {\n        return this.clone({ name, value, op: 'd' });\n    }\n    maybeSetNormalizedName(name, lcName) {\n        if (!this.normalizedNames.has(lcName)) {\n            this.normalizedNames.set(lcName, name);\n        }\n    }\n    init() {\n        if (!!this.lazyInit) {\n            if (this.lazyInit instanceof HttpHeaders) {\n                this.copyFrom(this.lazyInit);\n            }\n            else {\n                this.lazyInit();\n            }\n            this.lazyInit = null;\n            if (!!this.lazyUpdate) {\n                this.lazyUpdate.forEach(update => this.applyUpdate(update));\n                this.lazyUpdate = null;\n            }\n        }\n    }\n    copyFrom(other) {\n        other.init();\n        Array.from(other.headers.keys()).forEach(key => {\n            this.headers.set(key, other.headers.get(key));\n            this.normalizedNames.set(key, other.normalizedNames.get(key));\n        });\n    }\n    clone(update) {\n        const clone = new HttpHeaders();\n        clone.lazyInit =\n            (!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;\n        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);\n        return clone;\n    }\n    applyUpdate(update) {\n        const key = update.name.toLowerCase();\n        switch (update.op) {\n            case 'a':\n            case 's':\n                let value = update.value;\n                if (typeof value === 'string') {\n                    value = [value];\n                }\n                if (value.length === 0) {\n                    return;\n                }\n                this.maybeSetNormalizedName(update.name, key);\n                const base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];\n                base.push(...value);\n                this.headers.set(key, base);\n                break;\n            case 'd':\n                const toDelete = update.value;\n                if (!toDelete) {\n                    this.headers.delete(key);\n                    this.normalizedNames.delete(key);\n                }\n                else {\n                    let existing = this.headers.get(key);\n                    if (!existing) {\n                        return;\n                    }\n                    existing = existing.filter(value => toDelete.indexOf(value) === -1);\n                    if (existing.length === 0) {\n                        this.headers.delete(key);\n                        this.normalizedNames.delete(key);\n                    }\n                    else {\n                        this.headers.set(key, existing);\n                    }\n                }\n                break;\n        }\n    }\n    setHeaderEntries(name, values) {\n        const headerValues = (Array.isArray(values) ? values : [values]).map((value) => value.toString());\n        const key = name.toLowerCase();\n        this.headers.set(key, headerValues);\n        this.maybeSetNormalizedName(name, key);\n    }\n    /**\n     * @internal\n     */\n    forEach(fn) {\n        this.init();\n        Array.from(this.normalizedNames.keys())\n            .forEach(key => fn(this.normalizedNames.get(key), this.headers.get(key)));\n    }\n}\n/**\n * Verifies that the headers object has the right shape: the values\n * must be either strings, numbers or arrays. Throws an error if an invalid\n * header value is present.\n */\nfunction assertValidHeaders(headers) {\n    for (const [key, value] of Object.entries(headers)) {\n        if (!(typeof value === 'string' || typeof value === 'number') && !Array.isArray(value)) {\n            throw new Error(`Unexpected value of the \\`${key}\\` header provided. ` +\n                `Expecting either a string, a number or an array, but got: \\`${value}\\`.`);\n        }\n    }\n}\n\n/**\n * Provides encoding and decoding of URL parameter and query-string values.\n *\n * Serializes and parses URL parameter keys and values to encode and decode them.\n * If you pass URL query parameters without encoding,\n * the query parameters can be misinterpreted at the receiving end.\n *\n *\n * @publicApi\n */\nclass HttpUrlEncodingCodec {\n    /**\n     * Encodes a key name for a URL parameter or query-string.\n     * @param key The key name.\n     * @returns The encoded key name.\n     */\n    encodeKey(key) {\n        return standardEncoding(key);\n    }\n    /**\n     * Encodes the value of a URL parameter or query-string.\n     * @param value The value.\n     * @returns The encoded value.\n     */\n    encodeValue(value) {\n        return standardEncoding(value);\n    }\n    /**\n     * Decodes an encoded URL parameter or query-string key.\n     * @param key The encoded key name.\n     * @returns The decoded key name.\n     */\n    decodeKey(key) {\n        return decodeURIComponent(key);\n    }\n    /**\n     * Decodes an encoded URL parameter or query-string value.\n     * @param value The encoded value.\n     * @returns The decoded value.\n     */\n    decodeValue(value) {\n        return decodeURIComponent(value);\n    }\n}\nfunction paramParser(rawParams, codec) {\n    const map = new Map();\n    if (rawParams.length > 0) {\n        // The `window.location.search` can be used while creating an instance of the `HttpParams` class\n        // (e.g. `new HttpParams({ fromString: window.location.search })`). The `window.location.search`\n        // may start with the `?` char, so we strip it if it's present.\n        const params = rawParams.replace(/^\\?/, '').split('&');\n        params.forEach((param) => {\n            const eqIdx = param.indexOf('=');\n            const [key, val] = eqIdx == -1 ?\n                [codec.decodeKey(param), ''] :\n                [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];\n            const list = map.get(key) || [];\n            list.push(val);\n            map.set(key, list);\n        });\n    }\n    return map;\n}\n/**\n * Encode input string with standard encodeURIComponent and then un-encode specific characters.\n */\nconst STANDARD_ENCODING_REGEX = /%(\\d[a-f0-9])/gi;\nconst STANDARD_ENCODING_REPLACEMENTS = {\n    '40': '@',\n    '3A': ':',\n    '24': '$',\n    '2C': ',',\n    '3B': ';',\n    '3D': '=',\n    '3F': '?',\n    '2F': '/',\n};\nfunction standardEncoding(v) {\n    return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s, t) => STANDARD_ENCODING_REPLACEMENTS[t] ?? s);\n}\nfunction valueToString(value) {\n    return `${value}`;\n}\n/**\n * An HTTP request/response body that represents serialized parameters,\n * per the MIME type `application/x-www-form-urlencoded`.\n *\n * This class is immutable; all mutation operations return a new instance.\n *\n * @publicApi\n */\nclass HttpParams {\n    constructor(options = {}) {\n        this.updates = null;\n        this.cloneFrom = null;\n        this.encoder = options.encoder || new HttpUrlEncodingCodec();\n        if (!!options.fromString) {\n            if (!!options.fromObject) {\n                throw new Error(`Cannot specify both fromString and fromObject.`);\n            }\n            this.map = paramParser(options.fromString, this.encoder);\n        }\n        else if (!!options.fromObject) {\n            this.map = new Map();\n            Object.keys(options.fromObject).forEach(key => {\n                const value = options.fromObject[key];\n                // convert the values to strings\n                const values = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];\n                this.map.set(key, values);\n            });\n        }\n        else {\n            this.map = null;\n        }\n    }\n    /**\n     * Reports whether the body includes one or more values for a given parameter.\n     * @param param The parameter name.\n     * @returns True if the parameter has one or more values,\n     * false if it has no value or is not present.\n     */\n    has(param) {\n        this.init();\n        return this.map.has(param);\n    }\n    /**\n     * Retrieves the first value for a parameter.\n     * @param param The parameter name.\n     * @returns The first value of the given parameter,\n     * or `null` if the parameter is not present.\n     */\n    get(param) {\n        this.init();\n        const res = this.map.get(param);\n        return !!res ? res[0] : null;\n    }\n    /**\n     * Retrieves all values for a  parameter.\n     * @param param The parameter name.\n     * @returns All values in a string array,\n     * or `null` if the parameter not present.\n     */\n    getAll(param) {\n        this.init();\n        return this.map.get(param) || null;\n    }\n    /**\n     * Retrieves all the parameters for this body.\n     * @returns The parameter names in a string array.\n     */\n    keys() {\n        this.init();\n        return Array.from(this.map.keys());\n    }\n    /**\n     * Appends a new value to existing values for a parameter.\n     * @param param The parameter name.\n     * @param value The new value to add.\n     * @return A new body with the appended value.\n     */\n    append(param, value) {\n        return this.clone({ param, value, op: 'a' });\n    }\n    /**\n     * Constructs a new body with appended values for the given parameter name.\n     * @param params parameters and values\n     * @return A new body with the new value.\n     */\n    appendAll(params) {\n        const updates = [];\n        Object.keys(params).forEach(param => {\n            const value = params[param];\n            if (Array.isArray(value)) {\n                value.forEach(_value => {\n                    updates.push({ param, value: _value, op: 'a' });\n                });\n            }\n            else {\n                updates.push({ param, value: value, op: 'a' });\n            }\n        });\n        return this.clone(updates);\n    }\n    /**\n     * Replaces the value for a parameter.\n     * @param param The parameter name.\n     * @param value The new value.\n     * @return A new body with the new value.\n     */\n    set(param, value) {\n        return this.clone({ param, value, op: 's' });\n    }\n    /**\n     * Removes a given value or all values from a parameter.\n     * @param param The parameter name.\n     * @param value The value to remove, if provided.\n     * @return A new body with the given value removed, or with all values\n     * removed if no value is specified.\n     */\n    delete(param, value) {\n        return this.clone({ param, value, op: 'd' });\n    }\n    /**\n     * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are\n     * separated by `&`s.\n     */\n    toString() {\n        this.init();\n        return this.keys()\n            .map(key => {\n            const eKey = this.encoder.encodeKey(key);\n            // `a: ['1']` produces `'a=1'`\n            // `b: []` produces `''`\n            // `c: ['1', '2']` produces `'c=1&c=2'`\n            return this.map.get(key).map(value => eKey + '=' + this.encoder.encodeValue(value))\n                .join('&');\n        })\n            // filter out empty values because `b: []` produces `''`\n            // which results in `a=1&&c=1&c=2` instead of `a=1&c=1&c=2` if we don't\n            .filter(param => param !== '')\n            .join('&');\n    }\n    clone(update) {\n        const clone = new HttpParams({ encoder: this.encoder });\n        clone.cloneFrom = this.cloneFrom || this;\n        clone.updates = (this.updates || []).concat(update);\n        return clone;\n    }\n    init() {\n        if (this.map === null) {\n            this.map = new Map();\n        }\n        if (this.cloneFrom !== null) {\n            this.cloneFrom.init();\n            this.cloneFrom.keys().forEach(key => this.map.set(key, this.cloneFrom.map.get(key)));\n            this.updates.forEach(update => {\n                switch (update.op) {\n                    case 'a':\n                    case 's':\n                        const base = (update.op === 'a' ? this.map.get(update.param) : undefined) || [];\n                        base.push(valueToString(update.value));\n                        this.map.set(update.param, base);\n                        break;\n                    case 'd':\n                        if (update.value !== undefined) {\n                            let base = this.map.get(update.param) || [];\n                            const idx = base.indexOf(valueToString(update.value));\n                            if (idx !== -1) {\n                                base.splice(idx, 1);\n                            }\n                            if (base.length > 0) {\n                                this.map.set(update.param, base);\n                            }\n                            else {\n                                this.map.delete(update.param);\n                            }\n                        }\n                        else {\n                            this.map.delete(update.param);\n                            break;\n                        }\n                }\n            });\n            this.cloneFrom = this.updates = null;\n        }\n    }\n}\n\n/**\n * A token used to manipulate and access values stored in `HttpContext`.\n *\n * @publicApi\n */\nclass HttpContextToken {\n    constructor(defaultValue) {\n        this.defaultValue = defaultValue;\n    }\n}\n/**\n * Http context stores arbitrary user defined values and ensures type safety without\n * actually knowing the types. It is backed by a `Map` and guarantees that keys do not clash.\n *\n * This context is mutable and is shared between cloned requests unless explicitly specified.\n *\n * @usageNotes\n *\n * ### Usage Example\n *\n * ```typescript\n * // inside cache.interceptors.ts\n * export const IS_CACHE_ENABLED = new HttpContextToken<boolean>(() => false);\n *\n * export class CacheInterceptor implements HttpInterceptor {\n *\n *   intercept(req: HttpRequest<any>, delegate: HttpHandler): Observable<HttpEvent<any>> {\n *     if (req.context.get(IS_CACHE_ENABLED) === true) {\n *       return ...;\n *     }\n *     return delegate.handle(req);\n *   }\n * }\n *\n * // inside a service\n *\n * this.httpClient.get('/api/weather', {\n *   context: new HttpContext().set(IS_CACHE_ENABLED, true)\n * }).subscribe(...);\n * ```\n *\n * @publicApi\n */\nclass HttpContext {\n    constructor() {\n        this.map = new Map();\n    }\n    /**\n     * Store a value in the context. If a value is already present it will be overwritten.\n     *\n     * @param token The reference to an instance of `HttpContextToken`.\n     * @param value The value to store.\n     *\n     * @returns A reference to itself for easy chaining.\n     */\n    set(token, value) {\n        this.map.set(token, value);\n        return this;\n    }\n    /**\n     * Retrieve the value associated with the given token.\n     *\n     * @param token The reference to an instance of `HttpContextToken`.\n     *\n     * @returns The stored value or default if one is defined.\n     */\n    get(token) {\n        if (!this.map.has(token)) {\n            this.map.set(token, token.defaultValue());\n        }\n        return this.map.get(token);\n    }\n    /**\n     * Delete the value associated with the given token.\n     *\n     * @param token The reference to an instance of `HttpContextToken`.\n     *\n     * @returns A reference to itself for easy chaining.\n     */\n    delete(token) {\n        this.map.delete(token);\n        return this;\n    }\n    /**\n     * Checks for existence of a given token.\n     *\n     * @param token The reference to an instance of `HttpContextToken`.\n     *\n     * @returns True if the token exists, false otherwise.\n     */\n    has(token) {\n        return this.map.has(token);\n    }\n    /**\n     * @returns a list of tokens currently stored in the context.\n     */\n    keys() {\n        return this.map.keys();\n    }\n}\n\n/**\n * Determine whether the given HTTP method may include a body.\n */\nfunction mightHaveBody(method) {\n    switch (method) {\n        case 'DELETE':\n        case 'GET':\n        case 'HEAD':\n        case 'OPTIONS':\n        case 'JSONP':\n            return false;\n        default:\n            return true;\n    }\n}\n/**\n * Safely assert whether the given value is an ArrayBuffer.\n *\n * In some execution environments ArrayBuffer is not defined.\n */\nfunction isArrayBuffer(value) {\n    return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\n}\n/**\n * Safely assert whether the given value is a Blob.\n *\n * In some execution environments Blob is not defined.\n */\nfunction isBlob(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\n/**\n * Safely assert whether the given value is a FormData instance.\n *\n * In some execution environments FormData is not defined.\n */\nfunction isFormData(value) {\n    return typeof FormData !== 'undefined' && value instanceof FormData;\n}\n/**\n * Safely assert whether the given value is a URLSearchParams instance.\n *\n * In some execution environments URLSearchParams is not defined.\n */\nfunction isUrlSearchParams(value) {\n    return typeof URLSearchParams !== 'undefined' && value instanceof URLSearchParams;\n}\n/**\n * An outgoing HTTP request with an optional typed body.\n *\n * `HttpRequest` represents an outgoing request, including URL, method,\n * headers, body, and other request configuration options. Instances should be\n * assumed to be immutable. To modify a `HttpRequest`, the `clone`\n * method should be used.\n *\n * @publicApi\n */\nclass HttpRequest {\n    constructor(method, url, third, fourth) {\n        this.url = url;\n        /**\n         * The request body, or `null` if one isn't set.\n         *\n         * Bodies are not enforced to be immutable, as they can include a reference to any\n         * user-defined data type. However, interceptors should take care to preserve\n         * idempotence by treating them as such.\n         */\n        this.body = null;\n        /**\n         * Whether this request should be made in a way that exposes progress events.\n         *\n         * Progress events are expensive (change detection runs on each event) and so\n         * they should only be requested if the consumer intends to monitor them.\n         *\n         * Note: The `FetchBackend` doesn't support progress report on uploads.\n         */\n        this.reportProgress = false;\n        /**\n         * Whether this request should be sent with outgoing credentials (cookies).\n         */\n        this.withCredentials = false;\n        /**\n         * The expected response type of the server.\n         *\n         * This is used to parse the response appropriately before returning it to\n         * the requestee.\n         */\n        this.responseType = 'json';\n        this.method = method.toUpperCase();\n        // Next, need to figure out which argument holds the HttpRequestInit\n        // options, if any.\n        let options;\n        // Check whether a body argument is expected. The only valid way to omit\n        // the body argument is to use a known no-body method like GET.\n        if (mightHaveBody(this.method) || !!fourth) {\n            // Body is the third argument, options are the fourth.\n            this.body = (third !== undefined) ? third : null;\n            options = fourth;\n        }\n        else {\n            // No body required, options are the third argument. The body stays null.\n            options = third;\n        }\n        // If options have been passed, interpret them.\n        if (options) {\n            // Normalize reportProgress and withCredentials.\n            this.reportProgress = !!options.reportProgress;\n            this.withCredentials = !!options.withCredentials;\n            // Override default response type of 'json' if one is provided.\n            if (!!options.responseType) {\n                this.responseType = options.responseType;\n            }\n            // Override headers if they're provided.\n            if (!!options.headers) {\n                this.headers = options.headers;\n            }\n            if (!!options.context) {\n                this.context = options.context;\n            }\n            if (!!options.params) {\n                this.params = options.params;\n            }\n            // We do want to assign transferCache even if it's falsy (false is valid value)\n            this.transferCache = options.transferCache;\n        }\n        // If no headers have been passed in, construct a new HttpHeaders instance.\n        if (!this.headers) {\n            this.headers = new HttpHeaders();\n        }\n        // If no context have been passed in, construct a new HttpContext instance.\n        if (!this.context) {\n            this.context = new HttpContext();\n        }\n        // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.\n        if (!this.params) {\n            this.params = new HttpParams();\n            this.urlWithParams = url;\n        }\n        else {\n            // Encode the parameters to a string in preparation for inclusion in the URL.\n            const params = this.params.toString();\n            if (params.length === 0) {\n                // No parameters, the visible URL is just the URL given at creation time.\n                this.urlWithParams = url;\n            }\n            else {\n                // Does the URL already have query parameters? Look for '?'.\n                const qIdx = url.indexOf('?');\n                // There are 3 cases to handle:\n                // 1) No existing parameters -> append '?' followed by params.\n                // 2) '?' exists and is followed by existing query string ->\n                //    append '&' followed by params.\n                // 3) '?' exists at the end of the url -> append params directly.\n                // This basically amounts to determining the character, if any, with\n                // which to join the URL and parameters.\n                const sep = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');\n                this.urlWithParams = url + sep + params;\n            }\n        }\n    }\n    /**\n     * Transform the free-form body into a serialized format suitable for\n     * transmission to the server.\n     */\n    serializeBody() {\n        // If no body is present, no need to serialize it.\n        if (this.body === null) {\n            return null;\n        }\n        // Check whether the body is already in a serialized form. If so,\n        // it can just be returned directly.\n        if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||\n            isUrlSearchParams(this.body) || typeof this.body === 'string') {\n            return this.body;\n        }\n        // Check whether the body is an instance of HttpUrlEncodedParams.\n        if (this.body instanceof HttpParams) {\n            return this.body.toString();\n        }\n        // Check whether the body is an object or array, and serialize with JSON if so.\n        if (typeof this.body === 'object' || typeof this.body === 'boolean' ||\n            Array.isArray(this.body)) {\n            return JSON.stringify(this.body);\n        }\n        // Fall back on toString() for everything else.\n        return this.body.toString();\n    }\n    /**\n     * Examine the body and attempt to infer an appropriate MIME type\n     * for it.\n     *\n     * If no such type can be inferred, this method will return `null`.\n     */\n    detectContentTypeHeader() {\n        // An empty body has no content type.\n        if (this.body === null) {\n            return null;\n        }\n        // FormData bodies rely on the browser's content type assignment.\n        if (isFormData(this.body)) {\n            return null;\n        }\n        // Blobs usually have their own content type. If it doesn't, then\n        // no type can be inferred.\n        if (isBlob(this.body)) {\n            return this.body.type || null;\n        }\n        // Array buffers have unknown contents and thus no type can be inferred.\n        if (isArrayBuffer(this.body)) {\n            return null;\n        }\n        // Technically, strings could be a form of JSON data, but it's safe enough\n        // to assume they're plain strings.\n        if (typeof this.body === 'string') {\n            return 'text/plain';\n        }\n        // `HttpUrlEncodedParams` has its own content-type.\n        if (this.body instanceof HttpParams) {\n            return 'application/x-www-form-urlencoded;charset=UTF-8';\n        }\n        // Arrays, objects, boolean and numbers will be encoded as JSON.\n        if (typeof this.body === 'object' || typeof this.body === 'number' ||\n            typeof this.body === 'boolean') {\n            return 'application/json';\n        }\n        // No type could be inferred.\n        return null;\n    }\n    clone(update = {}) {\n        // For method, url, and responseType, take the current value unless\n        // it is overridden in the update hash.\n        const method = update.method || this.method;\n        const url = update.url || this.url;\n        const responseType = update.responseType || this.responseType;\n        // The body is somewhat special - a `null` value in update.body means\n        // whatever current body is present is being overridden with an empty\n        // body, whereas an `undefined` value in update.body implies no\n        // override.\n        const body = (update.body !== undefined) ? update.body : this.body;\n        // Carefully handle the boolean options to differentiate between\n        // `false` and `undefined` in the update args.\n        const withCredentials = (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;\n        const reportProgress = (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;\n        // Headers and params may be appended to if `setHeaders` or\n        // `setParams` are used.\n        let headers = update.headers || this.headers;\n        let params = update.params || this.params;\n        // Pass on context if needed\n        const context = update.context ?? this.context;\n        // Check whether the caller has asked to add headers.\n        if (update.setHeaders !== undefined) {\n            // Set every requested header.\n            headers =\n                Object.keys(update.setHeaders)\n                    .reduce((headers, name) => headers.set(name, update.setHeaders[name]), headers);\n        }\n        // Check whether the caller has asked to set params.\n        if (update.setParams) {\n            // Set every requested param.\n            params = Object.keys(update.setParams)\n                .reduce((params, param) => params.set(param, update.setParams[param]), params);\n        }\n        // Finally, construct the new HttpRequest using the pieces from above.\n        return new HttpRequest(method, url, body, {\n            params,\n            headers,\n            context,\n            reportProgress,\n            responseType,\n            withCredentials,\n        });\n    }\n}\n\n/**\n * Type enumeration for the different kinds of `HttpEvent`.\n *\n * @publicApi\n */\nvar HttpEventType;\n(function (HttpEventType) {\n    /**\n     * The request was sent out over the wire.\n     */\n    HttpEventType[HttpEventType[\"Sent\"] = 0] = \"Sent\";\n    /**\n     * An upload progress event was received.\n     *\n     * Note: The `FetchBackend` doesn't support progress report on uploads.\n     */\n    HttpEventType[HttpEventType[\"UploadProgress\"] = 1] = \"UploadProgress\";\n    /**\n     * The response status code and headers were received.\n     */\n    HttpEventType[HttpEventType[\"ResponseHeader\"] = 2] = \"ResponseHeader\";\n    /**\n     * A download progress event was received.\n     */\n    HttpEventType[HttpEventType[\"DownloadProgress\"] = 3] = \"DownloadProgress\";\n    /**\n     * The full response including the body was received.\n     */\n    HttpEventType[HttpEventType[\"Response\"] = 4] = \"Response\";\n    /**\n     * A custom event from an interceptor or a backend.\n     */\n    HttpEventType[HttpEventType[\"User\"] = 5] = \"User\";\n})(HttpEventType || (HttpEventType = {}));\n/**\n * Base class for both `HttpResponse` and `HttpHeaderResponse`.\n *\n * @publicApi\n */\nclass HttpResponseBase {\n    /**\n     * Super-constructor for all responses.\n     *\n     * The single parameter accepted is an initialization hash. Any properties\n     * of the response passed there will override the default values.\n     */\n    constructor(init, defaultStatus = 200 /* HttpStatusCode.Ok */, defaultStatusText = 'OK') {\n        // If the hash has values passed, use them to initialize the response.\n        // Otherwise use the default values.\n        this.headers = init.headers || new HttpHeaders();\n        this.status = init.status !== undefined ? init.status : defaultStatus;\n        this.statusText = init.statusText || defaultStatusText;\n        this.url = init.url || null;\n        // Cache the ok value to avoid defining a getter.\n        this.ok = this.status >= 200 && this.status < 300;\n    }\n}\n/**\n * A partial HTTP response which only includes the status and header data,\n * but no response body.\n *\n * `HttpHeaderResponse` is a `HttpEvent` available on the response\n * event stream, only when progress events are requested.\n *\n * @publicApi\n */\nclass HttpHeaderResponse extends HttpResponseBase {\n    /**\n     * Create a new `HttpHeaderResponse` with the given parameters.\n     */\n    constructor(init = {}) {\n        super(init);\n        this.type = HttpEventType.ResponseHeader;\n    }\n    /**\n     * Copy this `HttpHeaderResponse`, overriding its contents with the\n     * given parameter hash.\n     */\n    clone(update = {}) {\n        // Perform a straightforward initialization of the new HttpHeaderResponse,\n        // overriding the current parameters with new ones if given.\n        return new HttpHeaderResponse({\n            headers: update.headers || this.headers,\n            status: update.status !== undefined ? update.status : this.status,\n            statusText: update.statusText || this.statusText,\n            url: update.url || this.url || undefined,\n        });\n    }\n}\n/**\n * A full HTTP response, including a typed response body (which may be `null`\n * if one was not returned).\n *\n * `HttpResponse` is a `HttpEvent` available on the response event\n * stream.\n *\n * @publicApi\n */\nclass HttpResponse extends HttpResponseBase {\n    /**\n     * Construct a new `HttpResponse`.\n     */\n    constructor(init = {}) {\n        super(init);\n        this.type = HttpEventType.Response;\n        this.body = init.body !== undefined ? init.body : null;\n    }\n    clone(update = {}) {\n        return new HttpResponse({\n            body: (update.body !== undefined) ? update.body : this.body,\n            headers: update.headers || this.headers,\n            status: (update.status !== undefined) ? update.status : this.status,\n            statusText: update.statusText || this.statusText,\n            url: update.url || this.url || undefined,\n        });\n    }\n}\n/**\n * A response that represents an error or failure, either from a\n * non-successful HTTP status, an error while executing the request,\n * or some other failure which occurred during the parsing of the response.\n *\n * Any error returned on the `Observable` response stream will be\n * wrapped in an `HttpErrorResponse` to provide additional context about\n * the state of the HTTP layer when the error occurred. The error property\n * will contain either a wrapped Error object or the error response returned\n * from the server.\n *\n * @publicApi\n */\nclass HttpErrorResponse extends HttpResponseBase {\n    constructor(init) {\n        // Initialize with a default status of 0 / Unknown Error.\n        super(init, 0, 'Unknown Error');\n        this.name = 'HttpErrorResponse';\n        /**\n         * Errors are never okay, even when the status code is in the 2xx success range.\n         */\n        this.ok = false;\n        // If the response was successful, then this was a parse error. Otherwise, it was\n        // a protocol-level failure of some sort. Either the request failed in transit\n        // or the server returned an unsuccessful status code.\n        if (this.status >= 200 && this.status < 300) {\n            this.message = `Http failure during parsing for ${init.url || '(unknown url)'}`;\n        }\n        else {\n            this.message = `Http failure response for ${init.url || '(unknown url)'}: ${init.status} ${init.statusText}`;\n        }\n        this.error = init.error || null;\n    }\n}\n\n/**\n * Constructs an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and\n * the given `body`. This function clones the object and adds the body.\n *\n * Note that the `responseType` *options* value is a String that identifies the\n * single data type of the response.\n * A single overload version of the method handles each response type.\n * The value of `responseType` cannot be a union, as the combined signature could imply.\n *\n */\nfunction addBody(options, body) {\n    return {\n        body,\n        headers: options.headers,\n        context: options.context,\n        observe: options.observe,\n        params: options.params,\n        reportProgress: options.reportProgress,\n        responseType: options.responseType,\n        withCredentials: options.withCredentials,\n        transferCache: options.transferCache,\n    };\n}\n/**\n * Performs HTTP requests.\n * This service is available as an injectable class, with methods to perform HTTP requests.\n * Each request method has multiple signatures, and the return type varies based on\n * the signature that is called (mainly the values of `observe` and `responseType`).\n *\n * Note that the `responseType` *options* value is a String that identifies the\n * single data type of the response.\n * A single overload version of the method handles each response type.\n * The value of `responseType` cannot be a union, as the combined signature could imply.\n\n *\n * @usageNotes\n * Sample HTTP requests for the [Tour of Heroes](/tutorial/tour-of-heroes/toh-pt0) application.\n *\n * ### HTTP Request Example\n *\n * ```\n *  // GET heroes whose name contains search term\n * searchHeroes(term: string): observable<Hero[]>{\n *\n *  const params = new HttpParams({fromString: 'name=term'});\n *    return this.httpClient.request('GET', this.heroesUrl, {responseType:'json', params});\n * }\n * ```\n *\n * Alternatively, the parameter string can be used without invoking HttpParams\n * by directly joining to the URL.\n * ```\n * this.httpClient.request('GET', this.heroesUrl + '?' + 'name=term', {responseType:'json'});\n * ```\n *\n *\n * ### JSONP Example\n * ```\n * requestJsonp(url, callback = 'callback') {\n *  return this.httpClient.jsonp(this.heroesURL, callback);\n * }\n * ```\n *\n * ### PATCH Example\n * ```\n * // PATCH one of the heroes' name\n * patchHero (id: number, heroName: string): Observable<{}> {\n * const url = `${this.heroesUrl}/${id}`;   // PATCH api/heroes/42\n *  return this.httpClient.patch(url, {name: heroName}, httpOptions)\n *    .pipe(catchError(this.handleError('patchHero')));\n * }\n * ```\n *\n * @see [HTTP Guide](guide/understanding-communicating-with-http)\n * @see [HTTP Request](api/common/http/HttpRequest)\n *\n * @publicApi\n */\nclass HttpClient {\n    constructor(handler) {\n        this.handler = handler;\n    }\n    /**\n     * Constructs an observable for a generic HTTP request that, when subscribed,\n     * fires the request through the chain of registered interceptors and on to the\n     * server.\n     *\n     * You can pass an `HttpRequest` directly as the only parameter. In this case,\n     * the call returns an observable of the raw `HttpEvent` stream.\n     *\n     * Alternatively you can pass an HTTP method as the first parameter,\n     * a URL string as the second, and an options hash containing the request body as the third.\n     * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the\n     * type of returned observable.\n     *   * The `responseType` value determines how a successful response body is parsed.\n     *   * If `responseType` is the default `json`, you can pass a type interface for the resulting\n     * object as a type parameter to the call.\n     *\n     * The `observe` value determines the return type, according to what you are interested in\n     * observing.\n     *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including\n     * progress events by default.\n     *   * An `observe` value of response returns an observable of `HttpResponse<T>`,\n     * where the `T` parameter depends on the `responseType` and any optionally provided type\n     * parameter.\n     *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.\n     *\n     */\n    request(first, url, options = {}) {\n        let req;\n        // First, check whether the primary argument is an instance of `HttpRequest`.\n        if (first instanceof HttpRequest) {\n            // It is. The other arguments must be undefined (per the signatures) and can be\n            // ignored.\n            req = first;\n        }\n        else {\n            // It's a string, so it represents a URL. Construct a request based on it,\n            // and incorporate the remaining arguments (assuming `GET` unless a method is\n            // provided.\n            // Figure out the headers.\n            let headers = undefined;\n            if (options.headers instanceof HttpHeaders) {\n                headers = options.headers;\n            }\n            else {\n                headers = new HttpHeaders(options.headers);\n            }\n            // Sort out parameters.\n            let params = undefined;\n            if (!!options.params) {\n                if (options.params instanceof HttpParams) {\n                    params = options.params;\n                }\n                else {\n                    params = new HttpParams({ fromObject: options.params });\n                }\n            }\n            // Construct the request.\n            req = new HttpRequest(first, url, (options.body !== undefined ? options.body : null), {\n                headers,\n                context: options.context,\n                params,\n                reportProgress: options.reportProgress,\n                // By default, JSON is assumed to be returned for all calls.\n                responseType: options.responseType || 'json',\n                withCredentials: options.withCredentials,\n                transferCache: options.transferCache,\n            });\n        }\n        // Start with an Observable.of() the initial request, and run the handler (which\n        // includes all interceptors) inside a concatMap(). This way, the handler runs\n        // inside an Observable chain, which causes interceptors to be re-run on every\n        // subscription (this also makes retries re-run the handler, including interceptors).\n        const events$ = of(req).pipe(concatMap((req) => this.handler.handle(req)));\n        // If coming via the API signature which accepts a previously constructed HttpRequest,\n        // the only option is to get the event stream. Otherwise, return the event stream if\n        // that is what was requested.\n        if (first instanceof HttpRequest || options.observe === 'events') {\n            return events$;\n        }\n        // The requested stream contains either the full response or the body. In either\n        // case, the first step is to filter the event stream to extract a stream of\n        // responses(s).\n        const res$ = events$.pipe(filter((event) => event instanceof HttpResponse));\n        // Decide which stream to return.\n        switch (options.observe || 'body') {\n            case 'body':\n                // The requested stream is the body. Map the response stream to the response\n                // body. This could be done more simply, but a misbehaving interceptor might\n                // transform the response body into a different format and ignore the requested\n                // responseType. Guard against this by validating that the response is of the\n                // requested type.\n                switch (req.responseType) {\n                    case 'arraybuffer':\n                        return res$.pipe(map((res) => {\n                            // Validate that the body is an ArrayBuffer.\n                            if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                                throw new Error('Response is not an ArrayBuffer.');\n                            }\n                            return res.body;\n                        }));\n                    case 'blob':\n                        return res$.pipe(map((res) => {\n                            // Validate that the body is a Blob.\n                            if (res.body !== null && !(res.body instanceof Blob)) {\n                                throw new Error('Response is not a Blob.');\n                            }\n                            return res.body;\n                        }));\n                    case 'text':\n                        return res$.pipe(map((res) => {\n                            // Validate that the body is a string.\n                            if (res.body !== null && typeof res.body !== 'string') {\n                                throw new Error('Response is not a string.');\n                            }\n                            return res.body;\n                        }));\n                    case 'json':\n                    default:\n                        // No validation needed for JSON responses, as they can be of any type.\n                        return res$.pipe(map((res) => res.body));\n                }\n            case 'response':\n                // The response stream was requested directly, so return it.\n                return res$;\n            default:\n                // Guard against new future observe types being added.\n                throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);\n        }\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `DELETE` request to execute on the server. See the individual overloads for\n     * details on the return type.\n     *\n     * @param url     The endpoint URL.\n     * @param options The HTTP options to send with the request.\n     *\n     */\n    delete(url, options = {}) {\n        return this.request('DELETE', url, options);\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `GET` request to execute on the server. See the individual overloads for\n     * details on the return type.\n     */\n    get(url, options = {}) {\n        return this.request('GET', url, options);\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `HEAD` request to execute on the server. The `HEAD` method returns\n     * meta information about the resource without transferring the\n     * resource itself. See the individual overloads for\n     * details on the return type.\n     */\n    head(url, options = {}) {\n        return this.request('HEAD', url, options);\n    }\n    /**\n     * Constructs an `Observable` that, when subscribed, causes a request with the special method\n     * `JSONP` to be dispatched via the interceptor pipeline.\n     * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain\n     * API endpoints that don't support newer,\n     * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.\n     * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the\n     * requests even if the API endpoint is not located on the same domain (origin) as the client-side\n     * application making the request.\n     * The endpoint API must support JSONP callback for JSONP requests to work.\n     * The resource API returns the JSON response wrapped in a callback function.\n     * You can pass the callback function name as one of the query parameters.\n     * Note that JSONP requests can only be used with `GET` requests.\n     *\n     * @param url The resource URL.\n     * @param callbackParam The callback function name.\n     *\n     */\n    jsonp(url, callbackParam) {\n        return this.request('JSONP', url, {\n            params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n            observe: 'body',\n            responseType: 'json',\n        });\n    }\n    /**\n     * Constructs an `Observable` that, when subscribed, causes the configured\n     * `OPTIONS` request to execute on the server. This method allows the client\n     * to determine the supported HTTP methods and other capabilities of an endpoint,\n     * without implying a resource action. See the individual overloads for\n     * details on the return type.\n     */\n    options(url, options = {}) {\n        return this.request('OPTIONS', url, options);\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `PATCH` request to execute on the server. See the individual overloads for\n     * details on the return type.\n     */\n    patch(url, body, options = {}) {\n        return this.request('PATCH', url, addBody(options, body));\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `POST` request to execute on the server. The server responds with the location of\n     * the replaced resource. See the individual overloads for\n     * details on the return type.\n     */\n    post(url, body, options = {}) {\n        return this.request('POST', url, addBody(options, body));\n    }\n    /**\n     * Constructs an observable that, when subscribed, causes the configured\n     * `PUT` request to execute on the server. The `PUT` method replaces an existing resource\n     * with a new set of values.\n     * See the individual overloads for details on the return type.\n     */\n    put(url, body, options = {}) {\n        return this.request('PUT', url, addBody(options, body));\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClient, deps: [{ token: HttpHandler }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClient }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClient, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: HttpHandler }] });\n\nconst XSSI_PREFIX$1 = /^\\)\\]\\}',?\\n/;\nconst REQUEST_URL_HEADER = `X-Request-URL`;\n/**\n * Determine an appropriate URL for the response, by checking either\n * response url or the X-Request-URL header.\n */\nfunction getResponseUrl$1(response) {\n    if (response.url) {\n        return response.url;\n    }\n    // stored as lowercase in the map\n    const xRequestUrl = REQUEST_URL_HEADER.toLocaleLowerCase();\n    return response.headers.get(xRequestUrl);\n}\n/**\n * Uses `fetch` to send requests to a backend server.\n *\n * This `FetchBackend` requires the support of the\n * [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) which is available on all\n * supported browsers and on Node.js v18 or later.\n *\n * @see {@link HttpHandler}\n *\n * @publicApi\n */\nclass FetchBackend {\n    constructor() {\n        // We need to bind the native fetch to its context or it will throw an \"illegal invocation\"\n        this.fetchImpl = inject(FetchFactory, { optional: true })?.fetch ?? fetch.bind(globalThis);\n        this.ngZone = inject(NgZone);\n    }\n    handle(request) {\n        return new Observable(observer => {\n            const aborter = new AbortController();\n            this.doRequest(request, aborter.signal, observer)\n                .then(noop, error => observer.error(new HttpErrorResponse({ error })));\n            return () => aborter.abort();\n        });\n    }\n    async doRequest(request, signal, observer) {\n        const init = this.createRequestInit(request);\n        let response;\n        try {\n            const fetchPromise = this.fetchImpl(request.urlWithParams, { signal, ...init });\n            // Make sure Zone.js doesn't trigger false-positive unhandled promise\n            // error in case the Promise is rejected synchronously. See function\n            // description for additional information.\n            silenceSuperfluousUnhandledPromiseRejection(fetchPromise);\n            // Send the `Sent` event before awaiting the response.\n            observer.next({ type: HttpEventType.Sent });\n            response = await fetchPromise;\n        }\n        catch (error) {\n            observer.error(new HttpErrorResponse({\n                error,\n                status: error.status ?? 0,\n                statusText: error.statusText,\n                url: request.urlWithParams,\n                headers: error.headers,\n            }));\n            return;\n        }\n        const headers = new HttpHeaders(response.headers);\n        const statusText = response.statusText;\n        const url = getResponseUrl$1(response) ?? request.urlWithParams;\n        let status = response.status;\n        let body = null;\n        if (request.reportProgress) {\n            observer.next(new HttpHeaderResponse({ headers, status, statusText, url }));\n        }\n        if (response.body) {\n            // Read Progress\n            const contentLength = response.headers.get('content-length');\n            const chunks = [];\n            const reader = response.body.getReader();\n            let receivedLength = 0;\n            let decoder;\n            let partialText;\n            // We have to check whether the Zone is defined in the global scope because this may be called\n            // when the zone is nooped.\n            const reqZone = typeof Zone !== 'undefined' && Zone.current;\n            // Perform response processing outside of Angular zone to\n            // ensure no excessive change detection runs are executed\n            // Here calling the async ReadableStreamDefaultReader.read() is responsible for triggering CD\n            await this.ngZone.runOutsideAngular(async () => {\n                while (true) {\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    chunks.push(value);\n                    receivedLength += value.length;\n                    if (request.reportProgress) {\n                        partialText = request.responseType === 'text' ?\n                            (partialText ?? '') + (decoder ??= new TextDecoder).decode(value, { stream: true }) :\n                            undefined;\n                        const reportProgress = () => observer.next({\n                            type: HttpEventType.DownloadProgress,\n                            total: contentLength ? +contentLength : undefined,\n                            loaded: receivedLength,\n                            partialText,\n                        });\n                        reqZone ? reqZone.run(reportProgress) : reportProgress();\n                    }\n                }\n            });\n            // Combine all chunks.\n            const chunksAll = this.concatChunks(chunks, receivedLength);\n            try {\n                const contentType = response.headers.get('Content-Type') ?? '';\n                body = this.parseBody(request, chunksAll, contentType);\n            }\n            catch (error) {\n                // Body loading or parsing failed\n                observer.error(new HttpErrorResponse({\n                    error,\n                    headers: new HttpHeaders(response.headers),\n                    status: response.status,\n                    statusText: response.statusText,\n                    url: getResponseUrl$1(response) ?? request.urlWithParams,\n                }));\n                return;\n            }\n        }\n        // Same behavior as the XhrBackend\n        if (status === 0) {\n            status = body ? 200 /* HttpStatusCode.Ok */ : 0;\n        }\n        // ok determines whether the response will be transmitted on the event or\n        // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n        // but a successful status code can still result in an error if the user\n        // asked for JSON data and the body cannot be parsed as such.\n        const ok = status >= 200 && status < 300;\n        if (ok) {\n            observer.next(new HttpResponse({\n                body,\n                headers,\n                status,\n                statusText,\n                url,\n            }));\n            // The full body has been received and delivered, no further events\n            // are possible. This request is complete.\n            observer.complete();\n        }\n        else {\n            observer.error(new HttpErrorResponse({\n                error: body,\n                headers,\n                status,\n                statusText,\n                url,\n            }));\n        }\n    }\n    parseBody(request, binContent, contentType) {\n        switch (request.responseType) {\n            case 'json':\n                // stripping the XSSI when present\n                const text = new TextDecoder().decode(binContent).replace(XSSI_PREFIX$1, '');\n                return text === '' ? null : JSON.parse(text);\n            case 'text':\n                return new TextDecoder().decode(binContent);\n            case 'blob':\n                return new Blob([binContent], { type: contentType });\n            case 'arraybuffer':\n                return binContent.buffer;\n        }\n    }\n    createRequestInit(req) {\n        // We could share some of this logic with the XhrBackend\n        const headers = {};\n        const credentials = req.withCredentials ? 'include' : undefined;\n        // Setting all the requested headers.\n        req.headers.forEach((name, values) => (headers[name] = values.join(',')));\n        // Add an Accept header if one isn't present already.\n        headers['Accept'] ??= 'application/json, text/plain, */*';\n        // Auto-detect the Content-Type header if one isn't present already.\n        if (!headers['Content-Type']) {\n            const detectedType = req.detectContentTypeHeader();\n            // Sometimes Content-Type detection fails.\n            if (detectedType !== null) {\n                headers['Content-Type'] = detectedType;\n            }\n        }\n        return {\n            body: req.serializeBody(),\n            method: req.method,\n            headers,\n            credentials,\n        };\n    }\n    concatChunks(chunks, totalLength) {\n        const chunksAll = new Uint8Array(totalLength);\n        let position = 0;\n        for (const chunk of chunks) {\n            chunksAll.set(chunk, position);\n            position += chunk.length;\n        }\n        return chunksAll;\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: FetchBackend, deps: [], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: FetchBackend }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: FetchBackend, decorators: [{\n            type: Injectable\n        }] });\n/**\n * Abstract class to provide a mocked implementation of `fetch()`\n */\nclass FetchFactory {\n}\nfunction noop() { }\n/**\n * Zone.js treats a rejected promise that has not yet been awaited\n * as an unhandled error. This function adds a noop `.then` to make\n * sure that Zone.js doesn't throw an error if the Promise is rejected\n * synchronously.\n */\nfunction silenceSuperfluousUnhandledPromiseRejection(promise) {\n    promise.then(noop, noop);\n}\n\nfunction interceptorChainEndFn(req, finalHandlerFn) {\n    return finalHandlerFn(req);\n}\n/**\n * Constructs a `ChainedInterceptorFn` which adapts a legacy `HttpInterceptor` to the\n * `ChainedInterceptorFn` interface.\n */\nfunction adaptLegacyInterceptorToChain(chainTailFn, interceptor) {\n    return (initialRequest, finalHandlerFn) => interceptor.intercept(initialRequest, {\n        handle: (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn),\n    });\n}\n/**\n * Constructs a `ChainedInterceptorFn` which wraps and invokes a functional interceptor in the given\n * injector.\n */\nfunction chainedInterceptorFn(chainTailFn, interceptorFn, injector) {\n    // clang-format off\n    return (initialRequest, finalHandlerFn) => runInInjectionContext(injector, () => interceptorFn(initialRequest, downstreamRequest => chainTailFn(downstreamRequest, finalHandlerFn)));\n    // clang-format on\n}\n/**\n * A multi-provider token that represents the array of registered\n * `HttpInterceptor` objects.\n *\n * @publicApi\n */\nconst HTTP_INTERCEPTORS = new InjectionToken(ngDevMode ? 'HTTP_INTERCEPTORS' : '');\n/**\n * A multi-provided token of `HttpInterceptorFn`s.\n */\nconst HTTP_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? 'HTTP_INTERCEPTOR_FNS' : '');\n/**\n * A multi-provided token of `HttpInterceptorFn`s that are only set in root.\n */\nconst HTTP_ROOT_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? 'HTTP_ROOT_INTERCEPTOR_FNS' : '');\n/**\n * A provider to set a global primary http backend. If set, it will override the default one\n */\nconst PRIMARY_HTTP_BACKEND = new InjectionToken(ngDevMode ? 'PRIMARY_HTTP_BACKEND' : '');\n/**\n * Creates an `HttpInterceptorFn` which lazily initializes an interceptor chain from the legacy\n * class-based interceptors and runs the request through it.\n */\nfunction legacyInterceptorFnFactory() {\n    let chain = null;\n    return (req, handler) => {\n        if (chain === null) {\n            const interceptors = inject(HTTP_INTERCEPTORS, { optional: true }) ?? [];\n            // Note: interceptors are wrapped right-to-left so that final execution order is\n            // left-to-right. That is, if `interceptors` is the array `[a, b, c]`, we want to\n            // produce a chain that is conceptually `c(b(a(end)))`, which we build from the inside\n            // out.\n            chain = interceptors.reduceRight(adaptLegacyInterceptorToChain, interceptorChainEndFn);\n        }\n        const pendingTasks = inject(InitialRenderPendingTasks);\n        const taskId = pendingTasks.add();\n        return chain(req, handler).pipe(finalize(() => pendingTasks.remove(taskId)));\n    };\n}\nlet fetchBackendWarningDisplayed = false;\n/** Internal function to reset the flag in tests */\nfunction resetFetchBackendWarningFlag() {\n    fetchBackendWarningDisplayed = false;\n}\nclass HttpInterceptorHandler extends HttpHandler {\n    constructor(backend, injector) {\n        super();\n        this.backend = backend;\n        this.injector = injector;\n        this.chain = null;\n        this.pendingTasks = inject(InitialRenderPendingTasks);\n        // Check if there is a preferred HTTP backend configured and use it if that's the case.\n        // This is needed to enable `FetchBackend` globally for all HttpClient's when `withFetch`\n        // is used.\n        const primaryHttpBackend = inject(PRIMARY_HTTP_BACKEND, { optional: true });\n        this.backend = primaryHttpBackend ?? backend;\n        // We strongly recommend using fetch backend for HTTP calls when SSR is used\n        // for an application. The logic below checks if that's the case and produces\n        // a warning otherwise.\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && !fetchBackendWarningDisplayed) {\n            const isServer = isPlatformServer(injector.get(PLATFORM_ID));\n            if (isServer && !(this.backend instanceof FetchBackend)) {\n                fetchBackendWarningDisplayed = true;\n                injector.get(Console).warn(formatRuntimeError(2801 /* RuntimeErrorCode.NOT_USING_FETCH_BACKEND_IN_SSR */, 'Angular detected that `HttpClient` is not configured ' +\n                    'to use `fetch` APIs. It\\'s strongly recommended to ' +\n                    'enable `fetch` for applications that use Server-Side Rendering ' +\n                    'for better performance and compatibility. ' +\n                    'To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` ' +\n                    'call at the root of the application.'));\n            }\n        }\n    }\n    handle(initialRequest) {\n        if (this.chain === null) {\n            const dedupedInterceptorFns = Array.from(new Set([\n                ...this.injector.get(HTTP_INTERCEPTOR_FNS),\n                ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, []),\n            ]));\n            // Note: interceptors are wrapped right-to-left so that final execution order is\n            // left-to-right. That is, if `dedupedInterceptorFns` is the array `[a, b, c]`, we want to\n            // produce a chain that is conceptually `c(b(a(end)))`, which we build from the inside\n            // out.\n            this.chain = dedupedInterceptorFns.reduceRight((nextSequencedFn, interceptorFn) => chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector), interceptorChainEndFn);\n        }\n        const taskId = this.pendingTasks.add();\n        return this.chain(initialRequest, downstreamRequest => this.backend.handle(downstreamRequest))\n            .pipe(finalize(() => this.pendingTasks.remove(taskId)));\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpInterceptorHandler, deps: [{ token: HttpBackend }, { token: i0.EnvironmentInjector }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpInterceptorHandler }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpInterceptorHandler, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: HttpBackend }, { type: i0.EnvironmentInjector }] });\n\n// Every request made through JSONP needs a callback name that's unique across the\n// whole page. Each request is assigned an id and the callback name is constructed\n// from that. The next id to be assigned is tracked in a global variable here that\n// is shared among all applications on the page.\nlet nextRequestId = 0;\n/**\n * When a pending <script> is unsubscribed we'll move it to this document, so it won't be\n * executed.\n */\nlet foreignDocument;\n// Error text given when a JSONP script is injected, but doesn't invoke the callback\n// passed in its URL.\nconst JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n// Error text given when a request is passed to the JsonpClientBackend that doesn't\n// have a request method JSONP.\nconst JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nconst JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n// Error text given when a request is passed to the JsonpClientBackend that has\n// headers set\nconst JSONP_ERR_HEADERS_NOT_SUPPORTED = 'JSONP requests do not support headers.';\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n *\n * In the browser, this should always be the `window` object.\n *\n *\n */\nclass JsonpCallbackContext {\n}\n/**\n * Factory function that determines where to store JSONP callbacks.\n *\n * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist\n * in test environments. In that case, callbacks are stored on an anonymous object instead.\n *\n *\n */\nfunction jsonpCallbackContext() {\n    if (typeof window === 'object') {\n        return window;\n    }\n    return {};\n}\n/**\n * Processes an `HttpRequest` with the JSONP method,\n * by performing JSONP style requests.\n * @see {@link HttpHandler}\n * @see {@link HttpXhrBackend}\n *\n * @publicApi\n */\nclass JsonpClientBackend {\n    constructor(callbackMap, document) {\n        this.callbackMap = callbackMap;\n        this.document = document;\n        /**\n         * A resolved promise that can be used to schedule microtasks in the event handlers.\n         */\n        this.resolvedPromise = Promise.resolve();\n    }\n    /**\n     * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n     */\n    nextCallback() {\n        return `ng_jsonp_callback_${nextRequestId++}`;\n    }\n    /**\n     * Processes a JSONP request and returns an event stream of the results.\n     * @param req The request object.\n     * @returns An observable of the response events.\n     *\n     */\n    handle(req) {\n        // Firstly, check both the method and response type. If either doesn't match\n        // then the request was improperly routed here and cannot be handled.\n        if (req.method !== 'JSONP') {\n            throw new Error(JSONP_ERR_WRONG_METHOD);\n        }\n        else if (req.responseType !== 'json') {\n            throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);\n        }\n        // Check the request headers. JSONP doesn't support headers and\n        // cannot set any that were supplied.\n        if (req.headers.keys().length > 0) {\n            throw new Error(JSONP_ERR_HEADERS_NOT_SUPPORTED);\n        }\n        // Everything else happens inside the Observable boundary.\n        return new Observable((observer) => {\n            // The first step to make a request is to generate the callback name, and replace the\n            // callback placeholder in the URL with the name. Care has to be taken here to ensure\n            // a trailing &, if matched, gets inserted back into the URL in the correct place.\n            const callback = this.nextCallback();\n            const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n            // Construct the <script> tag and point it at the URL.\n            const node = this.document.createElement('script');\n            node.src = url;\n            // A JSONP request requires waiting for multiple callbacks. These variables\n            // are closed over and track state across those callbacks.\n            // The response object, if one has been received, or null otherwise.\n            let body = null;\n            // Whether the response callback has been called.\n            let finished = false;\n            // Set the response callback in this.callbackMap (which will be the window\n            // object in the browser. The script being loaded via the <script> tag will\n            // eventually call this callback.\n            this.callbackMap[callback] = (data) => {\n                // Data has been received from the JSONP script. Firstly, delete this callback.\n                delete this.callbackMap[callback];\n                // Set state to indicate data was received.\n                body = data;\n                finished = true;\n            };\n            // cleanup() is a utility closure that removes the <script> from the page and\n            // the response callback from the window. This logic is used in both the\n            // success, error, and cancellation paths, so it's extracted out for convenience.\n            const cleanup = () => {\n                // Remove the <script> tag if it's still on the page.\n                if (node.parentNode) {\n                    node.parentNode.removeChild(node);\n                }\n                // Remove the response callback from the callbackMap (window object in the\n                // browser).\n                delete this.callbackMap[callback];\n            };\n            // onLoad() is the success callback which runs after the response callback\n            // if the JSONP script loads successfully. The event itself is unimportant.\n            // If something went wrong, onLoad() may run without the response callback\n            // having been invoked.\n            const onLoad = (event) => {\n                // We wrap it in an extra Promise, to ensure the microtask\n                // is scheduled after the loaded endpoint has executed any potential microtask itself,\n                // which is not guaranteed in Internet Explorer and EdgeHTML. See issue #39496\n                this.resolvedPromise.then(() => {\n                    // Cleanup the page.\n                    cleanup();\n                    // Check whether the response callback has run.\n                    if (!finished) {\n                        // It hasn't, something went wrong with the request. Return an error via\n                        // the Observable error path. All JSONP errors have status 0.\n                        observer.error(new HttpErrorResponse({\n                            url,\n                            status: 0,\n                            statusText: 'JSONP Error',\n                            error: new Error(JSONP_ERR_NO_CALLBACK),\n                        }));\n                        return;\n                    }\n                    // Success. body either contains the response body or null if none was\n                    // returned.\n                    observer.next(new HttpResponse({\n                        body,\n                        status: 200 /* HttpStatusCode.Ok */,\n                        statusText: 'OK',\n                        url,\n                    }));\n                    // Complete the stream, the response is over.\n                    observer.complete();\n                });\n            };\n            // onError() is the error callback, which runs if the script returned generates\n            // a Javascript error. It emits the error via the Observable error channel as\n            // a HttpErrorResponse.\n            const onError = (error) => {\n                cleanup();\n                // Wrap the error in a HttpErrorResponse.\n                observer.error(new HttpErrorResponse({\n                    error,\n                    status: 0,\n                    statusText: 'JSONP Error',\n                    url,\n                }));\n            };\n            // Subscribe to both the success (load) and error events on the <script> tag,\n            // and add it to the page.\n            node.addEventListener('load', onLoad);\n            node.addEventListener('error', onError);\n            this.document.body.appendChild(node);\n            // The request has now been successfully sent.\n            observer.next({ type: HttpEventType.Sent });\n            // Cancellation handler.\n            return () => {\n                if (!finished) {\n                    this.removeListeners(node);\n                }\n                // And finally, clean up the page.\n                cleanup();\n            };\n        });\n    }\n    removeListeners(script) {\n        // Issue #34818\n        // Changing <script>'s ownerDocument will prevent it from execution.\n        // https://html.spec.whatwg.org/multipage/scripting.html#execute-the-script-block\n        if (!foreignDocument) {\n            foreignDocument = this.document.implementation.createHTMLDocument();\n        }\n        foreignDocument.adoptNode(script);\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: JsonpClientBackend, deps: [{ token: JsonpCallbackContext }, { token: DOCUMENT }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: JsonpClientBackend }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: JsonpClientBackend, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: JsonpCallbackContext }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n/**\n * Identifies requests with the method JSONP and shifts them to the `JsonpClientBackend`.\n */\nfunction jsonpInterceptorFn(req, next) {\n    if (req.method === 'JSONP') {\n        return inject(JsonpClientBackend).handle(req);\n    }\n    // Fall through for normal HTTP requests.\n    return next(req);\n}\n/**\n * Identifies requests with the method JSONP and\n * shifts them to the `JsonpClientBackend`.\n *\n * @see {@link HttpInterceptor}\n *\n * @publicApi\n */\nclass JsonpInterceptor {\n    constructor(injector) {\n        this.injector = injector;\n    }\n    /**\n     * Identifies and handles a given JSONP request.\n     * @param initialRequest The outgoing request object to handle.\n     * @param next The next interceptor in the chain, or the backend\n     * if no interceptors remain in the chain.\n     * @returns An observable of the event stream.\n     */\n    intercept(initialRequest, next) {\n        return runInInjectionContext(this.injector, () => jsonpInterceptorFn(initialRequest, downstreamRequest => next.handle(downstreamRequest)));\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: JsonpInterceptor, deps: [{ token: i0.EnvironmentInjector }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: JsonpInterceptor }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: JsonpInterceptor, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: i0.EnvironmentInjector }] });\n\nconst XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n/**\n * Determine an appropriate URL for the response, by checking either\n * XMLHttpRequest.responseURL or the X-Request-URL header.\n */\nfunction getResponseUrl(xhr) {\n    if ('responseURL' in xhr && xhr.responseURL) {\n        return xhr.responseURL;\n    }\n    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n        return xhr.getResponseHeader('X-Request-URL');\n    }\n    return null;\n}\n/**\n * Uses `XMLHttpRequest` to send requests to a backend server.\n * @see {@link HttpHandler}\n * @see {@link JsonpClientBackend}\n *\n * @publicApi\n */\nclass HttpXhrBackend {\n    constructor(xhrFactory) {\n        this.xhrFactory = xhrFactory;\n    }\n    /**\n     * Processes a request and returns a stream of response events.\n     * @param req The request object.\n     * @returns An observable of the response events.\n     */\n    handle(req) {\n        // Quick check to give a better error message when a user attempts to use\n        // HttpClient.jsonp() without installing the HttpClientJsonpModule\n        if (req.method === 'JSONP') {\n            throw new RuntimeError(-2800 /* RuntimeErrorCode.MISSING_JSONP_MODULE */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \\`withJsonpSupport()\\` call (if \\`provideHttpClient()\\` is used) or import the \\`HttpClientJsonpModule\\` in the root NgModule.`);\n        }\n        // Check whether this factory has a special function to load an XHR implementation\n        // for various non-browser environments. We currently limit it to only `ServerXhr`\n        // class, which needs to load an XHR implementation.\n        const xhrFactory = this.xhrFactory;\n        const source = xhrFactory.loadImpl ? from(xhrFactory.loadImpl()) : of(null);\n        return source.pipe(switchMap(() => {\n            // Everything happens on Observable subscription.\n            return new Observable((observer) => {\n                // Start by setting up the XHR object with request method, URL, and withCredentials\n                // flag.\n                const xhr = xhrFactory.build();\n                xhr.open(req.method, req.urlWithParams);\n                if (req.withCredentials) {\n                    xhr.withCredentials = true;\n                }\n                // Add all the requested headers.\n                req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));\n                // Add an Accept header if one isn't present already.\n                if (!req.headers.has('Accept')) {\n                    xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');\n                }\n                // Auto-detect the Content-Type header if one isn't present already.\n                if (!req.headers.has('Content-Type')) {\n                    const detectedType = req.detectContentTypeHeader();\n                    // Sometimes Content-Type detection fails.\n                    if (detectedType !== null) {\n                        xhr.setRequestHeader('Content-Type', detectedType);\n                    }\n                }\n                // Set the responseType if one was requested.\n                if (req.responseType) {\n                    const responseType = req.responseType.toLowerCase();\n                    // JSON responses need to be processed as text. This is because if the server\n                    // returns an XSSI-prefixed JSON response, the browser will fail to parse it,\n                    // xhr.response will be null, and xhr.responseText cannot be accessed to\n                    // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON\n                    // is parsed by first requesting text and then applying JSON.parse.\n                    xhr.responseType = ((responseType !== 'json') ? responseType : 'text');\n                }\n                // Serialize the request body if one is present. If not, this will be set to null.\n                const reqBody = req.serializeBody();\n                // If progress events are enabled, response headers will be delivered\n                // in two events - the HttpHeaderResponse event and the full HttpResponse\n                // event. However, since response headers don't change in between these\n                // two events, it doesn't make sense to parse them twice. So headerResponse\n                // caches the data extracted from the response whenever it's first parsed,\n                // to ensure parsing isn't duplicated.\n                let headerResponse = null;\n                // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest\n                // state, and memoizes it into headerResponse.\n                const partialFromXhr = () => {\n                    if (headerResponse !== null) {\n                        return headerResponse;\n                    }\n                    const statusText = xhr.statusText || 'OK';\n                    // Parse headers from XMLHttpRequest - this step is lazy.\n                    const headers = new HttpHeaders(xhr.getAllResponseHeaders());\n                    // Read the response URL from the XMLHttpResponse instance and fall back on the\n                    // request URL.\n                    const url = getResponseUrl(xhr) || req.url;\n                    // Construct the HttpHeaderResponse and memoize it.\n                    headerResponse =\n                        new HttpHeaderResponse({ headers, status: xhr.status, statusText, url });\n                    return headerResponse;\n                };\n                // Next, a few closures are defined for the various events which XMLHttpRequest can\n                // emit. This allows them to be unregistered as event listeners later.\n                // First up is the load event, which represents a response being fully available.\n                const onLoad = () => {\n                    // Read response state from the memoized partial data.\n                    let { headers, status, statusText, url } = partialFromXhr();\n                    // The body will be read out if present.\n                    let body = null;\n                    if (status !== 204 /* HttpStatusCode.NoContent */) {\n                        // Use XMLHttpRequest.response if set, responseText otherwise.\n                        body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;\n                    }\n                    // Normalize another potential bug (this one comes from CORS).\n                    if (status === 0) {\n                        status = !!body ? 200 /* HttpStatusCode.Ok */ : 0;\n                    }\n                    // ok determines whether the response will be transmitted on the event or\n                    // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n                    // but a successful status code can still result in an error if the user\n                    // asked for JSON data and the body cannot be parsed as such.\n                    let ok = status >= 200 && status < 300;\n                    // Check whether the body needs to be parsed as JSON (in many cases the browser\n                    // will have done that already).\n                    if (req.responseType === 'json' && typeof body === 'string') {\n                        // Save the original body, before attempting XSSI prefix stripping.\n                        const originalBody = body;\n                        body = body.replace(XSSI_PREFIX, '');\n                        try {\n                            // Attempt the parse. If it fails, a parse error should be delivered to the\n                            // user.\n                            body = body !== '' ? JSON.parse(body) : null;\n                        }\n                        catch (error) {\n                            // Since the JSON.parse failed, it's reasonable to assume this might not have\n                            // been a JSON response. Restore the original body (including any XSSI prefix)\n                            // to deliver a better error response.\n                            body = originalBody;\n                            // If this was an error request to begin with, leave it as a string, it\n                            // probably just isn't JSON. Otherwise, deliver the parsing error to the user.\n                            if (ok) {\n                                // Even though the response status was 2xx, this is still an error.\n                                ok = false;\n                                // The parse error contains the text of the body that failed to parse.\n                                body = { error, text: body };\n                            }\n                        }\n                    }\n                    if (ok) {\n                        // A successful response is delivered on the event stream.\n                        observer.next(new HttpResponse({\n                            body,\n                            headers,\n                            status,\n                            statusText,\n                            url: url || undefined,\n                        }));\n                        // The full body has been received and delivered, no further events\n                        // are possible. This request is complete.\n                        observer.complete();\n                    }\n                    else {\n                        // An unsuccessful request is delivered on the error channel.\n                        observer.error(new HttpErrorResponse({\n                            // The error in this case is the response body (error from the server).\n                            error: body,\n                            headers,\n                            status,\n                            statusText,\n                            url: url || undefined,\n                        }));\n                    }\n                };\n                // The onError callback is called when something goes wrong at the network level.\n                // Connection timeout, DNS error, offline, etc. These are actual errors, and are\n                // transmitted on the error channel.\n                const onError = (error) => {\n                    const { url } = partialFromXhr();\n                    const res = new HttpErrorResponse({\n                        error,\n                        status: xhr.status || 0,\n                        statusText: xhr.statusText || 'Unknown Error',\n                        url: url || undefined,\n                    });\n                    observer.error(res);\n                };\n                // The sentHeaders flag tracks whether the HttpResponseHeaders event\n                // has been sent on the stream. This is necessary to track if progress\n                // is enabled since the event will be sent on only the first download\n                // progress event.\n                let sentHeaders = false;\n                // The download progress event handler, which is only registered if\n                // progress events are enabled.\n                const onDownProgress = (event) => {\n                    // Send the HttpResponseHeaders event if it hasn't been sent already.\n                    if (!sentHeaders) {\n                        observer.next(partialFromXhr());\n                        sentHeaders = true;\n                    }\n                    // Start building the download progress event to deliver on the response\n                    // event stream.\n                    let progressEvent = {\n                        type: HttpEventType.DownloadProgress,\n                        loaded: event.loaded,\n                    };\n                    // Set the total number of bytes in the event if it's available.\n                    if (event.lengthComputable) {\n                        progressEvent.total = event.total;\n                    }\n                    // If the request was for text content and a partial response is\n                    // available on XMLHttpRequest, include it in the progress event\n                    // to allow for streaming reads.\n                    if (req.responseType === 'text' && !!xhr.responseText) {\n                        progressEvent.partialText = xhr.responseText;\n                    }\n                    // Finally, fire the event.\n                    observer.next(progressEvent);\n                };\n                // The upload progress event handler, which is only registered if\n                // progress events are enabled.\n                const onUpProgress = (event) => {\n                    // Upload progress events are simpler. Begin building the progress\n                    // event.\n                    let progress = {\n                        type: HttpEventType.UploadProgress,\n                        loaded: event.loaded,\n                    };\n                    // If the total number of bytes being uploaded is available, include\n                    // it.\n                    if (event.lengthComputable) {\n                        progress.total = event.total;\n                    }\n                    // Send the event.\n                    observer.next(progress);\n                };\n                // By default, register for load and error events.\n                xhr.addEventListener('load', onLoad);\n                xhr.addEventListener('error', onError);\n                xhr.addEventListener('timeout', onError);\n                xhr.addEventListener('abort', onError);\n                // Progress events are only enabled if requested.\n                if (req.reportProgress) {\n                    // Download progress is always enabled if requested.\n                    xhr.addEventListener('progress', onDownProgress);\n                    // Upload progress depends on whether there is a body to upload.\n                    if (reqBody !== null && xhr.upload) {\n                        xhr.upload.addEventListener('progress', onUpProgress);\n                    }\n                }\n                // Fire the request, and notify the event stream that it was fired.\n                xhr.send(reqBody);\n                observer.next({ type: HttpEventType.Sent });\n                // This is the return from the Observable function, which is the\n                // request cancellation handler.\n                return () => {\n                    // On a cancellation, remove all registered event listeners.\n                    xhr.removeEventListener('error', onError);\n                    xhr.removeEventListener('abort', onError);\n                    xhr.removeEventListener('load', onLoad);\n                    xhr.removeEventListener('timeout', onError);\n                    if (req.reportProgress) {\n                        xhr.removeEventListener('progress', onDownProgress);\n                        if (reqBody !== null && xhr.upload) {\n                            xhr.upload.removeEventListener('progress', onUpProgress);\n                        }\n                    }\n                    // Finally, abort the in-flight request.\n                    if (xhr.readyState !== xhr.DONE) {\n                        xhr.abort();\n                    }\n                };\n            });\n        }));\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpXhrBackend, deps: [{ token: i1.XhrFactory }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpXhrBackend }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpXhrBackend, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: i1.XhrFactory }] });\n\nconst XSRF_ENABLED = new InjectionToken('XSRF_ENABLED');\nconst XSRF_DEFAULT_COOKIE_NAME = 'XSRF-TOKEN';\nconst XSRF_COOKIE_NAME = new InjectionToken('XSRF_COOKIE_NAME', {\n    providedIn: 'root',\n    factory: () => XSRF_DEFAULT_COOKIE_NAME,\n});\nconst XSRF_DEFAULT_HEADER_NAME = 'X-XSRF-TOKEN';\nconst XSRF_HEADER_NAME = new InjectionToken('XSRF_HEADER_NAME', {\n    providedIn: 'root',\n    factory: () => XSRF_DEFAULT_HEADER_NAME,\n});\n/**\n * Retrieves the current XSRF token to use with the next outgoing request.\n *\n * @publicApi\n */\nclass HttpXsrfTokenExtractor {\n}\n/**\n * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.\n */\nclass HttpXsrfCookieExtractor {\n    constructor(doc, platform, cookieName) {\n        this.doc = doc;\n        this.platform = platform;\n        this.cookieName = cookieName;\n        this.lastCookieString = '';\n        this.lastToken = null;\n        /**\n         * @internal for testing\n         */\n        this.parseCount = 0;\n    }\n    getToken() {\n        if (this.platform === 'server') {\n            return null;\n        }\n        const cookieString = this.doc.cookie || '';\n        if (cookieString !== this.lastCookieString) {\n            this.parseCount++;\n            this.lastToken = parseCookieValue(cookieString, this.cookieName);\n            this.lastCookieString = cookieString;\n        }\n        return this.lastToken;\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpXsrfCookieExtractor, deps: [{ token: DOCUMENT }, { token: PLATFORM_ID }, { token: XSRF_COOKIE_NAME }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpXsrfCookieExtractor }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpXsrfCookieExtractor, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [XSRF_COOKIE_NAME]\n                }] }] });\nfunction xsrfInterceptorFn(req, next) {\n    const lcUrl = req.url.toLowerCase();\n    // Skip both non-mutating requests and absolute URLs.\n    // Non-mutating requests don't require a token, and absolute URLs require special handling\n    // anyway as the cookie set\n    // on our origin is not the same as the token expected by another origin.\n    if (!inject(XSRF_ENABLED) || req.method === 'GET' || req.method === 'HEAD' ||\n        lcUrl.startsWith('http://') || lcUrl.startsWith('https://')) {\n        return next(req);\n    }\n    const token = inject(HttpXsrfTokenExtractor).getToken();\n    const headerName = inject(XSRF_HEADER_NAME);\n    // Be careful not to overwrite an existing header of the same name.\n    if (token != null && !req.headers.has(headerName)) {\n        req = req.clone({ headers: req.headers.set(headerName, token) });\n    }\n    return next(req);\n}\n/**\n * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.\n */\nclass HttpXsrfInterceptor {\n    constructor(injector) {\n        this.injector = injector;\n    }\n    intercept(initialRequest, next) {\n        return runInInjectionContext(this.injector, () => xsrfInterceptorFn(initialRequest, downstreamRequest => next.handle(downstreamRequest)));\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpXsrfInterceptor, deps: [{ token: i0.EnvironmentInjector }], target: i0.FactoryTarget.Injectable }); }\n    static { this.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpXsrfInterceptor }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpXsrfInterceptor, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: i0.EnvironmentInjector }] });\n\n/**\n * Identifies a particular kind of `HttpFeature`.\n *\n * @publicApi\n */\nvar HttpFeatureKind;\n(function (HttpFeatureKind) {\n    HttpFeatureKind[HttpFeatureKind[\"Interceptors\"] = 0] = \"Interceptors\";\n    HttpFeatureKind[HttpFeatureKind[\"LegacyInterceptors\"] = 1] = \"LegacyInterceptors\";\n    HttpFeatureKind[HttpFeatureKind[\"CustomXsrfConfiguration\"] = 2] = \"CustomXsrfConfiguration\";\n    HttpFeatureKind[HttpFeatureKind[\"NoXsrfProtection\"] = 3] = \"NoXsrfProtection\";\n    HttpFeatureKind[HttpFeatureKind[\"JsonpSupport\"] = 4] = \"JsonpSupport\";\n    HttpFeatureKind[HttpFeatureKind[\"RequestsMadeViaParent\"] = 5] = \"RequestsMadeViaParent\";\n    HttpFeatureKind[HttpFeatureKind[\"Fetch\"] = 6] = \"Fetch\";\n})(HttpFeatureKind || (HttpFeatureKind = {}));\nfunction makeHttpFeature(kind, providers) {\n    return {\n        kind: kind,\n        providers: providers,\n    };\n}\n/**\n * Configures Angular's `HttpClient` service to be available for injection.\n *\n * By default, `HttpClient` will be configured for injection with its default options for XSRF\n * protection of outgoing requests. Additional configuration options can be provided by passing\n * feature functions to `provideHttpClient`. For example, HTTP interceptors can be added using the\n * `withInterceptors(...)` feature.\n *\n * <div class=\"alert is-helpful\">\n *\n * It's strongly recommended to enable\n * [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) for applications that use\n * Server-Side Rendering for better performance and compatibility. To enable `fetch`, add\n * `withFetch()` feature to the `provideHttpClient()` call at the root of the application:\n *\n * ```\n * provideHttpClient(withFetch());\n * ```\n *\n * </div>\n *\n * @see {@link withInterceptors}\n * @see {@link withInterceptorsFromDi}\n * @see {@link withXsrfConfiguration}\n * @see {@link withNoXsrfProtection}\n * @see {@link withJsonpSupport}\n * @see {@link withRequestsMadeViaParent}\n * @see {@link withFetch}\n */\nfunction provideHttpClient(...features) {\n    if (ngDevMode) {\n        const featureKinds = new Set(features.map(f => f.kind));\n        if (featureKinds.has(HttpFeatureKind.NoXsrfProtection) &&\n            featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)) {\n            throw new Error(ngDevMode ?\n                `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.` :\n                '');\n        }\n    }\n    const providers = [\n        HttpClient,\n        HttpXhrBackend,\n        HttpInterceptorHandler,\n        { provide: HttpHandler, useExisting: HttpInterceptorHandler },\n        { provide: HttpBackend, useExisting: HttpXhrBackend },\n        {\n            provide: HTTP_INTERCEPTOR_FNS,\n            useValue: xsrfInterceptorFn,\n            multi: true,\n        },\n        { provide: XSRF_ENABLED, useValue: true },\n        { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },\n    ];\n    for (const feature of features) {\n        providers.push(...feature.providers);\n    }\n    return makeEnvironmentProviders(providers);\n}\n/**\n * Adds one or more functional-style HTTP interceptors to the configuration of the `HttpClient`\n * instance.\n *\n * @see {@link HttpInterceptorFn}\n * @see {@link provideHttpClient}\n * @publicApi\n */\nfunction withInterceptors(interceptorFns) {\n    return makeHttpFeature(HttpFeatureKind.Interceptors, interceptorFns.map(interceptorFn => {\n        return {\n            provide: HTTP_INTERCEPTOR_FNS,\n            useValue: interceptorFn,\n            multi: true,\n        };\n    }));\n}\nconst LEGACY_INTERCEPTOR_FN = new InjectionToken('LEGACY_INTERCEPTOR_FN');\n/**\n * Includes class-based interceptors configured using a multi-provider in the current injector into\n * the configured `HttpClient` instance.\n *\n * Prefer `withInterceptors` and functional interceptors instead, as support for DI-provided\n * interceptors may be phased out in a later release.\n *\n * @see {@link HttpInterceptor}\n * @see {@link HTTP_INTERCEPTORS}\n * @see {@link provideHttpClient}\n */\nfunction withInterceptorsFromDi() {\n    // Note: the legacy interceptor function is provided here via an intermediate token\n    // (`LEGACY_INTERCEPTOR_FN`), using a pattern which guarantees that if these providers are\n    // included multiple times, all of the multi-provider entries will have the same instance of the\n    // interceptor function. That way, the `HttpINterceptorHandler` will dedup them and legacy\n    // interceptors will not run multiple times.\n    return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [\n        {\n            provide: LEGACY_INTERCEPTOR_FN,\n            useFactory: legacyInterceptorFnFactory,\n        },\n        {\n            provide: HTTP_INTERCEPTOR_FNS,\n            useExisting: LEGACY_INTERCEPTOR_FN,\n            multi: true,\n        }\n    ]);\n}\n/**\n * Customizes the XSRF protection for the configuration of the current `HttpClient` instance.\n *\n * This feature is incompatible with the `withNoXsrfProtection` feature.\n *\n * @see {@link provideHttpClient}\n */\nfunction withXsrfConfiguration({ cookieName, headerName }) {\n    const providers = [];\n    if (cookieName !== undefined) {\n        providers.push({ provide: XSRF_COOKIE_NAME, useValue: cookieName });\n    }\n    if (headerName !== undefined) {\n        providers.push({ provide: XSRF_HEADER_NAME, useValue: headerName });\n    }\n    return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers);\n}\n/**\n * Disables XSRF protection in the configuration of the current `HttpClient` instance.\n *\n * This feature is incompatible with the `withXsrfConfiguration` feature.\n *\n * @see {@link provideHttpClient}\n */\nfunction withNoXsrfProtection() {\n    return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [\n        {\n            provide: XSRF_ENABLED,\n            useValue: false,\n        },\n    ]);\n}\n/**\n * Add JSONP support to the configuration of the current `HttpClient` instance.\n *\n * @see {@link provideHttpClient}\n */\nfunction withJsonpSupport() {\n    return makeHttpFeature(HttpFeatureKind.JsonpSupport, [\n        JsonpClientBackend,\n        { provide: JsonpCallbackContext, useFactory: jsonpCallbackContext },\n        { provide: HTTP_INTERCEPTOR_FNS, useValue: jsonpInterceptorFn, multi: true },\n    ]);\n}\n/**\n * Configures the current `HttpClient` instance to make requests via the parent injector's\n * `HttpClient` instead of directly.\n *\n * By default, `provideHttpClient` configures `HttpClient` in its injector to be an independent\n * instance. For example, even if `HttpClient` is configured in the parent injector with\n * one or more interceptors, they will not intercept requests made via this instance.\n *\n * With this option enabled, once the request has passed through the current injector's\n * interceptors, it will be delegated to the parent injector's `HttpClient` chain instead of\n * dispatched directly, and interceptors in the parent configuration will be applied to the request.\n *\n * If there are several `HttpClient` instances in the injector hierarchy, it's possible for\n * `withRequestsMadeViaParent` to be used at multiple levels, which will cause the request to\n * \"bubble up\" until either reaching the root level or an `HttpClient` which was not configured with\n * this option.\n *\n * @see {@link provideHttpClient}\n * @developerPreview\n */\nfunction withRequestsMadeViaParent() {\n    return makeHttpFeature(HttpFeatureKind.RequestsMadeViaParent, [\n        {\n            provide: HttpBackend,\n            useFactory: () => {\n                const handlerFromParent = inject(HttpHandler, { skipSelf: true, optional: true });\n                if (ngDevMode && handlerFromParent === null) {\n                    throw new Error('withRequestsMadeViaParent() can only be used when the parent injector also configures HttpClient');\n                }\n                return handlerFromParent;\n            },\n        },\n    ]);\n}\n/**\n * Configures the current `HttpClient` instance to make requests using the fetch API.\n *\n * This `FetchBackend` requires the support of the Fetch API which is available on all evergreen\n * browsers and on NodeJS from v18 onward.\n *\n * Note: The Fetch API doesn't support progress report on uploads.\n *\n * @publicApi\n */\nfunction withFetch() {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && typeof fetch !== 'function') {\n        // TODO: Create a runtime error\n        // TODO: Use ENVIRONMENT_INITIALIZER to contextualize the error message (browser or server)\n        throw new Error('The `withFetch` feature of HttpClient requires the `fetch` API to be available. ' +\n            'If you run the code in a Node environment, make sure you use Node v18.10 or later.');\n    }\n    return makeHttpFeature(HttpFeatureKind.Fetch, [\n        FetchBackend,\n        { provide: HttpBackend, useExisting: FetchBackend },\n        { provide: PRIMARY_HTTP_BACKEND, useExisting: FetchBackend },\n    ]);\n}\n\n/**\n * Configures XSRF protection support for outgoing requests.\n *\n * For a server that supports a cookie-based XSRF protection system,\n * use directly to configure XSRF protection with the correct\n * cookie and header names.\n *\n * If no names are supplied, the default cookie name is `XSRF-TOKEN`\n * and the default header name is `X-XSRF-TOKEN`.\n *\n * @publicApi\n */\nclass HttpClientXsrfModule {\n    /**\n     * Disable the default XSRF protection.\n     */\n    static disable() {\n        return {\n            ngModule: HttpClientXsrfModule,\n            providers: [\n                withNoXsrfProtection().providers,\n            ],\n        };\n    }\n    /**\n     * Configure XSRF protection.\n     * @param options An object that can specify either or both\n     * cookie name or header name.\n     * - Cookie name default is `XSRF-TOKEN`.\n     * - Header name default is `X-XSRF-TOKEN`.\n     *\n     */\n    static withOptions(options = {}) {\n        return {\n            ngModule: HttpClientXsrfModule,\n            providers: withXsrfConfiguration(options).providers,\n        };\n    }\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientXsrfModule, deps: [], target: i0.FactoryTarget.NgModule }); }\n    static { this.mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientXsrfModule }); }\n    static { this.inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientXsrfModule, providers: [\n            HttpXsrfInterceptor,\n            { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },\n            { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },\n            withXsrfConfiguration({\n                cookieName: XSRF_DEFAULT_COOKIE_NAME,\n                headerName: XSRF_DEFAULT_HEADER_NAME,\n            }).providers,\n            { provide: XSRF_ENABLED, useValue: true },\n        ] }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientXsrfModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [\n                        HttpXsrfInterceptor,\n                        { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },\n                        { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },\n                        withXsrfConfiguration({\n                            cookieName: XSRF_DEFAULT_COOKIE_NAME,\n                            headerName: XSRF_DEFAULT_HEADER_NAME,\n                        }).providers,\n                        { provide: XSRF_ENABLED, useValue: true },\n                    ],\n                }]\n        }] });\n/**\n * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`\n * with supporting services for XSRF. Automatically imported by `HttpClientModule`.\n *\n * You can add interceptors to the chain behind `HttpClient` by binding them to the\n * multiprovider for built-in [DI token](guide/glossary#di-token) `HTTP_INTERCEPTORS`.\n *\n * @publicApi\n */\nclass HttpClientModule {\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientModule, deps: [], target: i0.FactoryTarget.NgModule }); }\n    static { this.mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientModule }); }\n    static { this.inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientModule, providers: [\n            provideHttpClient(withInterceptorsFromDi()),\n        ] }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    /**\n                     * Configures the [dependency injector](guide/glossary#injector) where it is imported\n                     * with supporting services for HTTP communications.\n                     */\n                    providers: [\n                        provideHttpClient(withInterceptorsFromDi()),\n                    ],\n                }]\n        }] });\n/**\n * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`\n * with supporting services for JSONP.\n * Without this module, Jsonp requests reach the backend\n * with method JSONP, where they are rejected.\n *\n * @publicApi\n */\nclass HttpClientJsonpModule {\n    static { this.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientJsonpModule, deps: [], target: i0.FactoryTarget.NgModule }); }\n    static { this.mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientJsonpModule }); }\n    static { this.inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientJsonpModule, providers: [\n            withJsonpSupport().providers,\n        ] }); }\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.6\", ngImport: i0, type: HttpClientJsonpModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [\n                        withJsonpSupport().providers,\n                    ],\n                }]\n        }] });\n\n/**\n * Keys within cached response data structure.\n */\nconst BODY = 'b';\nconst HEADERS = 'h';\nconst STATUS = 's';\nconst STATUS_TEXT = 'st';\nconst URL = 'u';\nconst RESPONSE_TYPE = 'rt';\nconst CACHE_OPTIONS = new InjectionToken(ngDevMode ? 'HTTP_TRANSFER_STATE_CACHE_OPTIONS' : '');\n/**\n * A list of allowed HTTP methods to cache.\n */\nconst ALLOWED_METHODS = ['GET', 'HEAD'];\nfunction transferCacheInterceptorFn(req, next) {\n    const { isCacheActive, ...globalOptions } = inject(CACHE_OPTIONS);\n    const { transferCache: requestOptions, method: requestMethod } = req;\n    // In the following situations we do not want to cache the request\n    if (!isCacheActive ||\n        // POST requests are allowed either globally or at request level\n        (requestMethod === 'POST' && !globalOptions.includePostRequests && !requestOptions) ||\n        (requestMethod !== 'POST' && !ALLOWED_METHODS.includes(requestMethod)) ||\n        requestOptions === false || //\n        (globalOptions.filter?.(req)) === false) {\n        return next(req);\n    }\n    const transferState = inject(TransferState);\n    const storeKey = makeCacheKey(req);\n    const response = transferState.get(storeKey, null);\n    let headersToInclude = globalOptions.includeHeaders;\n    if (typeof requestOptions === 'object' && requestOptions.includeHeaders) {\n        // Request-specific config takes precedence over the global config.\n        headersToInclude = requestOptions.includeHeaders;\n    }\n    if (response) {\n        const { [BODY]: undecodedBody, [RESPONSE_TYPE]: responseType, [HEADERS]: httpHeaders, [STATUS]: status, [STATUS_TEXT]: statusText, [URL]: url } = response;\n        // Request found in cache. Respond using it.\n        let body = undecodedBody;\n        switch (responseType) {\n            case 'arraybuffer':\n                body = new TextEncoder().encode(undecodedBody).buffer;\n                break;\n            case 'blob':\n                body = new Blob([undecodedBody]);\n                break;\n        }\n        // We want to warn users accessing a header provided from the cache\n        // That HttpTransferCache alters the headers\n        // The warning will be logged a single time by HttpHeaders instance\n        let headers = new HttpHeaders(httpHeaders);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            // Append extra logic in dev mode to produce a warning when a header\n            // that was not transferred to the client is accessed in the code via `get`\n            // and `has` calls.\n            headers = appendMissingHeadersDetection(req.url, headers, headersToInclude ?? []);\n        }\n        return of(new HttpResponse({\n            body,\n            headers,\n            status,\n            statusText,\n            url,\n        }));\n    }\n    // Request not found in cache. Make the request and cache it.\n    return next(req).pipe(tap((event) => {\n        if (event instanceof HttpResponse) {\n            transferState.set(storeKey, {\n                [BODY]: event.body,\n                [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),\n                [STATUS]: event.status,\n                [STATUS_TEXT]: event.statusText,\n                [URL]: event.url || '',\n                [RESPONSE_TYPE]: req.responseType,\n            });\n        }\n    }));\n}\nfunction getFilteredHeaders(headers, includeHeaders) {\n    if (!includeHeaders) {\n        return {};\n    }\n    const headersMap = {};\n    for (const key of includeHeaders) {\n        const values = headers.getAll(key);\n        if (values !== null) {\n            headersMap[key] = values;\n        }\n    }\n    return headersMap;\n}\nfunction makeCacheKey(request) {\n    // make the params encoded same as a url so it's easy to identify\n    const { params, method, responseType, url } = request;\n    const encodedParams = params.keys().sort().map((k) => `${k}=${params.getAll(k)}`).join('&');\n    const key = method + '.' + responseType + '.' + url + '?' + encodedParams;\n    const hash = generateHash(key);\n    return makeStateKey(hash);\n}\n/**\n * A method that returns a hash representation of a string using a variant of DJB2 hash\n * algorithm.\n *\n * This is the same hashing logic that is used to generate component ids.\n */\nfunction generateHash(value) {\n    let hash = 0;\n    for (const char of value) {\n        hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;\n    }\n    // Force positive number hash.\n    // 2147483647 = equivalent of Integer.MAX_VALUE.\n    hash += 2147483647 + 1;\n    return hash.toString();\n}\n/**\n * Returns the DI providers needed to enable HTTP transfer cache.\n *\n * By default, when using server rendering, requests are performed twice: once on the server and\n * other one on the browser.\n *\n * When these providers are added, requests performed on the server are cached and reused during the\n * bootstrapping of the application in the browser thus avoiding duplicate requests and reducing\n * load time.\n *\n */\nfunction withHttpTransferCache(cacheOptions) {\n    return [\n        {\n            provide: CACHE_OPTIONS,\n            useFactory: () => {\n                performanceMarkFeature('NgHttpTransferCache');\n                return { isCacheActive: true, ...cacheOptions };\n            }\n        },\n        {\n            provide: HTTP_ROOT_INTERCEPTOR_FNS,\n            useValue: transferCacheInterceptorFn,\n            multi: true,\n            deps: [TransferState, CACHE_OPTIONS]\n        },\n        {\n            provide: APP_BOOTSTRAP_LISTENER,\n            multi: true,\n            useFactory: () => {\n                const appRef = inject(ApplicationRef);\n                const cacheState = inject(CACHE_OPTIONS);\n                return () => {\n                    whenStable(appRef).then(() => {\n                        cacheState.isCacheActive = false;\n                    });\n                };\n            }\n        }\n    ];\n}\n/**\n * This function will add a proxy to an HttpHeader to intercept calls to get/has\n * and log a warning if the header entry requested has been removed\n */\nfunction appendMissingHeadersDetection(url, headers, headersToInclude) {\n    const warningProduced = new Set();\n    return new Proxy(headers, {\n        get(target, prop) {\n            const value = Reflect.get(target, prop);\n            const methods = new Set(['get', 'has', 'getAll']);\n            if (typeof value !== 'function' || !methods.has(prop)) {\n                return value;\n            }\n            return (headerName) => {\n                // We log when the key has been removed and a warning hasn't been produced for the header\n                const key = (prop + ':' + headerName).toLowerCase(); // e.g. `get:cache-control`\n                if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {\n                    warningProduced.add(key);\n                    const truncatedUrl = truncateMiddle(url);\n                    // TODO: create Error guide for this warning\n                    console.warn(formatRuntimeError(2802 /* RuntimeErrorCode.HEADERS_ALTERED_BY_TRANSFER_CACHE */, `Angular detected that the \\`${headerName}\\` header is accessed, but the value of the header ` +\n                        `was not transferred from the server to the client by the HttpTransferCache. ` +\n                        `To include the value of the \\`${headerName}\\` header for the \\`${truncatedUrl}\\` request, ` +\n                        `use the \\`includeHeaders\\` list. The \\`includeHeaders\\` can be defined either ` +\n                        `on a request level by adding the \\`transferCache\\` parameter, or on an application ` +\n                        `level by adding the \\`httpCacheTransfer.includeHeaders\\` argument to the ` +\n                        `\\`provideClientHydration()\\` call. `));\n                }\n                // invoking the original method\n                return value.apply(target, [headerName]);\n            };\n        }\n    });\n}\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FetchBackend, HTTP_INTERCEPTORS, HttpBackend, HttpClient, HttpClientJsonpModule, HttpClientModule, HttpClientXsrfModule, HttpContext, HttpContextToken, HttpErrorResponse, HttpEventType, HttpFeatureKind, HttpHandler, HttpHeaderResponse, HttpHeaders, HttpParams, HttpRequest, HttpResponse, HttpResponseBase, HttpUrlEncodingCodec, HttpXhrBackend, HttpXsrfTokenExtractor, JsonpClientBackend, JsonpInterceptor, provideHttpClient, withFetch, withInterceptors, withInterceptorsFromDi, withJsonpSupport, withNoXsrfProtection, withRequestsMadeViaParent, withXsrfConfiguration, HTTP_ROOT_INTERCEPTOR_FNS as HTTP_ROOT_INTERCEPTOR_FNS, HttpInterceptorHandler as HttpInterceptingHandler, HttpInterceptorHandler as HttpInterceptorHandler, PRIMARY_HTTP_BACKEND as PRIMARY_HTTP_BACKEND, withHttpTransferCache as withHttpTransferCache };\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n};\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]}